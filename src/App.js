import React, { useState, useEffect } from 'react';
import { Terminal, Github, GitBranch, FolderOpen, RefreshCcw, Lock, Workflow } from 'lucide-react'; // Icons

// Data structure for the guide content
const guideContent = [
  {
    id: 'intro',
    title: 'I. מבוא לממשק שורת הפקודה (CLI) ולבקרת גרסאות',
    icon: <Terminal className="w-5 h-5" />,
    sections: [
      {
        title: 'מהו הטרמינל/CLI ומדוע הוא חיוני?',
        content: `
ממשק שורת פקודה (CLI) הוא ממשק משתמש מבוסס טקסט המשמש להפעלת תוכניות, ניהול קבצי מחשב ואינטראקציה עם המחשב באמצעות מקלדת. הוא מהווה ניגוד לממשקי משתמש גרפיים (GUIs), המסתמכים על ניווט ויזואלי ולחיצות עכבר. ה-CLI מאפשר למשתמשים להזין פקודות טקסט כדי להגדיר, לנווט או להפעיל תוכניות בכל שרת או מערכת מחשב, כאשר כל מערכות ההפעלה העיקריות – כולל לינוקס, macOS ו-Windows – מספקות ממשק כזה.

היתרונות של ה-CLI הם רבים ומשמעותיים. ראשית, הוא מציע יעילות גבוהה; במקום לאתר וללחוץ על קבצים בודדים, ניתן לבצע פעולות על מספר קבצים בפקודת טקסט אחת. שליטה בפקודות מאפשרת ניווט ואינטראקציה מהירים עם המערכת, וכן יצירת סקריפטים לאוטומציה של משימות מונוטוניות או חוזרות על עצמן. היכולת הזו להפוך פעולות מורכבות ורב-שלביות לפקודות בודדות או סקריפטים אוטומטיים היא עקרון יסוד בהנדסת תוכנה לניהול מורכבות והבטחת עקביות. בכך, ה-CLI הופך לממשק העיקרי לאינטראקציה פרוגרמטית, ולא רק לכלי מיושן.

שנית, ה-CLI מאפשר גישה מרחוק יעילה. יישומים CLI צורכים פחות משאבי רשת בהשוואה ליישומים גרפיים, מה שהופך אותם למתאימים למערכות עם יכולות חומרה מlimited או לסביבות שרת מרוחקות. ניתן לנהל שרתים מרחוק באמצעות שליחת פקודות דרך Secure Shell (SSH), אפילו בחיבורי רוחב פס נמוכים, והוא השיטה המועדפת לניהול שרתים ומופעי ענן, במיוחד בסביבות "חסרות ראש" (headless) שבהן אין ממשק גרפי זמין.

שלישית, ה-CLI הוא כלי רב ערך לפתרון בעיות. השימוש בו מעודד הבנה עמוקה יותר של המערכת הבסיסית, משפר את השליטה בכלים ושירותים שונים, ומקל על ניהול שגיאות. לדוגמה, ניתן להשתמש ב-CLI כדי לצפות ביומני מערכת ולאתר במהירות הודעות שגיאה מקיפות ומידע ניפוי באגים. פקודות מבוססות טקסט קלות לתיעוד, מה שמבטיח שניתן לשחזר משימות ומקל על פתרון בעיות עתידיות.

לבסוף, ה-CLI הוא רב-גוני ומשמש במגוון רחב של תחומים: מנהלי מערכות משתמשים בו לתיקון בעיות, בדיקת תצורות ועדכון מכונות מרחוק; מפתחי תוכנה משתמשים בכלי CLI כדי לחסוך זמן ולייעל את זרימות העבודה, למשל בגישה לספריות צד שלישי; בסביבות ענן, ה-CLI חיוני לניהול מכונות וירטואליות, קונטיינרים ושירותי ענן; ומנהלי רשת משתמשים בו להגדרת נתבים, מתגים וחומות אש, ולניטור תעבורת רשת ופתרון בעיות קישוריות.

פעולת ה-CLI מתבצעת באמצעות מעטפת (shell) – תוכנית המתווכת בין המשתמש למערכת ההפעלה (לדוגמה, Bash, cmd.exe, PowerShell). כאשר פקודה מוזנת, מעטפת ה-CLI מנתחת אותה, מאתרת את הקובץ ההפעלה המתאים באמצעות משתנה ה-PATH של המערכת (רשימת ספריות שבהן נמצאים קבצי מערכת), מפעילה את הקובץ עם האפשרויות והארגומנטים שצוינו, ומציגה את הפלט שהמערכת מייצרת (הודעות מידע, שגיאה, נתונים מבוקשים או תוצאת הפעולה). תהליך זה של הזנת פקודות, ניתוח, ביצוע והצגת פלט חוזר בלולאה מתמדת, ומספק ממשק רציף לאינטראקציות מבוססות פקודות.
        `,
      },
      {
        title: 'הבנת Git: מערכת בקרת הגרסאות המבוזרת',
        content: `
Git היא מערכת בקרת גרסאות מבוזרת (DVCS) בקוד פתוח, שנוצרה בשנת 2005, ומסייעת לצוותי תוכנה לעקוב ולנהל שינויים בקוד שלהם ביעילות, במהירות ובאופן אסינכרוני.

בקרת גרסאות, המכונה גם בקרת מקור או בקרת תיקונים, היא תוכנה המשמשת למעקב אחר תיקונים, פתרון קונפליקטים באינטגרציה של קוד וניהול פריטים שונים בפרויקטי תוכנה (כגון עיצוב, נתונים, תמונות). היא מאפשרת תקשורת חלקה, שינויים ושחזור בין מפתחים וחברי צוות אחרים.

האופי המבוזר של Git הוא מאפיין מרכזי: בניגוד למערכות מרכזיות, Git מאפשר לכל מפתח להחזיק עותק מקומי מלא של בסיס הקוד של הפרויקט ושל כל ההיסטוריה שלו. המשמעות היא שפעולות כמו ביצוע שינויים (commit), יצירת ענפים (branching) ומיזוג (merging) יכולות להתבצע באופן מקומי ללא צורך בחיבור רשת קבוע. היכולת לעבוד במצב לא מקוון ולבצע ניסויים ללא חשש מנזק בלתי הפיך לקוד מטפחת סביבת פיתוח זריזה ופחות מסוכנת. מודל מבוזר זה הוא אבן יסוד בשיטות DevOps מודרניות ובאינטגרציה/אספקה מתמשכת, שבהן עבודה מהירה ועצמאית ואינטגרציה תכופה הן מפתח.

לשימוש ב-Git יתרונות רבים:
* **ניסויים**: צוותים יכולים להתנסות בתכונות חדשות או בתיקוני באגים באופן עצמאי באמצעות ענפים, עם היכולת לחזור לגרסאות קודמות אם מתעוררות בעיות.
* **מהירות וביצועים**: Git תוכנן למהירות, ופעולותיו (ביצוע שינויים, יצירת ענפים, מיזוג) מהירות בזכות מודל האחסון מבוסס-התמונות ופעולות מקומיות.
* **אבטחה**: Git מבטיח את שלמות קוד המקור באמצעות אלגוריתם גיבוב קריפטוגרפי SHA1 לכל האובייקטים (קבצים, ספריות, גרסאות, תגים ו-commits), ובכך מגן מפני שינויים מקריים או זדוניים.
* **גמישות**: המערכת תומכת בזרימות עבודה לא ליניאריות שונות, יעילה בפרויקטים קטנים וגדולים כאחד, ותואמת למערכות ופרוטוקולים קיימים רבים. יצירת ענפים ותיוג נחשבים ל"אזרחים ממדרגה ראשונה" ב-Git.
* **שיתוף פעולה**: Git מאפשר למספר מפתחים לעבוד בו-זמנית על פרויקט ללא הפרעה, תוך מעקב ומיזוג ענפים, ביקורת שינויים והאצת אספקת תוכנה.
* **גיבוי**: כל היסטוריית הפרויקט נשמרת באופן מקומי במאגר של כל מפתח, ומספקת גיבוי מקיף.
        `,
      },
      {
        title: 'GitHub: מרכז שיתוף הפעולה בענן',
        content: `
GitHub היא חברה שנוסדה בשנת 2008 ומספקת כלים המשתלבים עם Git. היא פלטפורמת קידוד חברתית שבה אנשים יכולים לשתף פעולה, לתאם ולשתף קבצים בסביבות מבוזרות ואסינכרוניות.

היחסים בין GitHub ל-Git הם יחסים של תלות הדדית: Git היא מערכת בקרת הגרסאות הבסיסית, בעוד GitHub היא שירות אירוח למאגרי Git. אין צורך ב-GitHub כדי להשתמש ב-Git, אך לא ניתן להשתמש ב-GitHub ללא Git.

הפופולריות של GitHub נובעת מיכולתה להפוך את פיתוח התוכנה לדמוקרטי. היא מורידה את חסמי הכניסה לשיתוף פעולה, מאפשרת חדשנות מהירה באמצעות קוד משותף ומטפחת קהילה גלובלית של מפתחים. זה גם מציג באופן מרומז את הצורך בשיטות אבטחה חזקות עבור בסיסי קוד משותפים.

תכונות מפתח של GitHub כוללות:
* אירוח מאגרי Git.
* הקלה על שיתוף פעולה בין מפתחים ברחבי העולם.
* ניהול בקרת גרסאות.
* הצעת תכונות כמו Pull Requests לביקורת קוד ודיון.
* תמיכה בפרויקטי קוד פתוח וגישה קלה למיליוני מאגרים ציבוריים.
* יכולת אוטומציה של משימות שגרתיות כמו בדיקות יחידה.
* תיעוד ותמיכה נרחבים.

קיימות גם חלופות ל-GitHub, המכונות "remotes", כגון GitLab, BitBucket, gogs ו-gittea.
        `,
      },
      {
        title: 'Git מול GitHub: הבהרת היחסים',
        content: `
כדי להבין את היחסים בין Git ל-GitHub, ניתן לחשוב על Git כמנוע ועל GitHub כמכונית. Git הוא הכלי מבוסס שורת הפקודה בקוד פתוח לבקרת גרסאות. הוא מנהל שינויים בקוד באופן מקומי במחשב המפתח. לעומת זאת, GitHub היא הפלטפורמה מבוססת האינטרנט המארחת מאגרי Git, מספקת ממשק שיתופי ומוסיפה תכונות כמו Pull Requests, מעקב אחר בעיות וניהול פרויקטים.

ניתן להפעיל את המנוע (Git) באופן עצמאי, אך המכונית (GitHub) מספקת חוויה נוחה, עשירה בתכונות ושיתופית יותר. למרות ש-Git ו-GitHub נפרדים, השאילתה מתייחסת ל"GitHub והטרמינל", מה שמרמז שהמשתמש יתמקד בעיקר באינטראקציה עם Git *דרך* הטרמינל, תוך ניצול GitHub לשיתוף פעולה מרחוק. הבחנה זו חיונית להבנה *מדוע* פקודות מסוימות משמשות (Git) ו*היכן* התוצאות משותפות/מנוהלות (GitHub). תלות הדדית זו אומרת ששליטה באחד ללא השני מגבילה את הפוטנציאל, ולכן הדוח יעבור בצורה חלקה בין פעולות Git מקומיות (ממוקדות טרמינל) לאינטראקציות GitHub מרחוק (הדורשות חשבון GitHub, כתובות URL מרוחקות וכו').
        `,
      },
    ],
  },
  {
    id: 'navigation',
    title: 'II. ניווט במערכת באמצעות הטרמינל',
    icon: <FolderOpen className="w-5 h-5" />,
    sections: [
      {
        title: 'פתיחת הטרמינל/שורת הפקודה (Windows, macOS, Linux)',
        content: `
פתיחת ממשק שורת הפקודה משתנה בהתאם למערכת ההפעלה, אך העקרונות הבסיסיים של השימוש בו נשארים זהים.

**ב-Windows (שורת הפקודה/CMD):**
* **תפריט התחלה**: יש ללחוץ על תפריט "התחלה", להקליד "cmd" או "שורת הפקודה" ולחץ על Enter.
* **תיבת הפעלה (Run Dialog)**: יש ללחוץ על מקש Windows + R, להקליד "cmd" ולחץ על Enter.
* **תפריט משתמש מתקדם (Power User Menu) (Windows 10/11)**: יש ללחוץ על מקש Windows + X ולבחור "שורת הפקודה" או "Windows Terminal" מהתפריט.

**ב-macOS (טרמינל):**
* **Launchpad**: יש ללחוץ על אייקון ה-Launchpad ב-Dock, להקליד "Terminal" בשדה החיפוש וללחוץ על אפליקציית "Terminal".
* **Finder**: יש לפתוח את תיקיית \`/Applications/Utilities\` ב-Finder, ולאחר מכן ללחוץ פעמיים על אפליקציית "Terminal".
* **חלון/לשונית חדשה**: ניתן ללחוץ על Command-N לחלון חדש או Command-T ללשונית חדשה.

**ב-Linux (אמולטור טרמינל):**
* **קיצור מקלדת**: קיצור הדרך הנפוץ ביותר הוא Ctrl + Alt + T.
* **תפריט יישומים**: יש לחפש "Terminal", "command", "prompt" או "shell" בתפריט היישומים.
* **אמולטורים נפוצים**: GNOME Terminal, Konsole, Terminator, xterm.

פתיחת הטרמינל היא השלב הראשון לאינטראקציה עם מערכת ההפעלה ברמה עמוקה יותר. בעוד ששיטת הגישה הספציפית תלויה במערכת ההפעלה, העקרונות הבסיסיים של אינטראקציה עם שורת הפקודה נשארים אחידים ברוב המערכות. הבנה זו מאפשרת למשתמשים לעבור בצורה חלקה בין סביבות שונות, תוך שימוש בידע נרכש.
        `,
      },
      {
        title: 'קיצורי מקלדת חיוניים לפרודוקטיביות בטרמינל',
        content: `
שליטה בקיצורי מקלדת בטרמינל משפרת באופן משמעותי את מהירות ושטף העבודה, מפחיתה את העומס הקוגניטיבי ומייעלת את האינטראקציה. קיצורים אלו הופכים את הטרמינל לכלי פרודוקטיבי ביותר:

* **ניווט**:
    * **חץ למעלה/למטה**: מציג את הפקודה האחרונה/הבאה בהיסטוריה.
    * **Tab**: השלמה אוטומטית של פקודות, שמות קבצים או ספריות.
    * **Ctrl + A / Ctrl + E**: מזיז את הסמן לתחילת/סוף השורה.
    * **Alt + B / Alt + F**: מזיז את הסמן מילה אחת אחורה/קדימה.
* **עריכה**:
    * **Ctrl + U**: מוחק מהסמן ועד תחילת השורה.
    * **Ctrl + K**: מוחק מהסמן ועד סוף השורה.
    * **Ctrl + W**: מוחק את המילה הקודמת.
    * **Ctrl + Y**: מדביק את הטקסט שנמחק לאחרונה.
* **שליטה ובקרה**:
    * **Ctrl + C**: מבטל/מפסיק את הפקודה/התהליך הנוכחי.
    * **Ctrl + D**: יוצא מהטרמינל/הפעלה הנוכחית.
    * **Ctrl + L / Command + K (macOS)**: מנקה את המסך.
    * **Ctrl + R**: מחפש בהיסטוריית הפקודות.

שליטה בקיצורי מקלדת אלו היא צעד קריטי למשתמשים חדשים המבקשים למקסם את יכולות הטרמינל ולבצע אינטראקציות מהירות ויעילות.
        `,
      },
      {
        title: 'ניווט בסיסי במערכת הקבצים: `pwd`, `ls`, `cd`',
        content: `
הבנת פקודות הניווט הבסיסיות בטרמינל חיונית לבניית מודל מנטלי של מבנה מערכת הקבצים וניווט יעיל בה. מודל זה, המבוסס על מבנה עץ עם ספריית שורש, ספריות אב וספריות בית, הוא הבסיס לכל פעולות ניהול הקבצים ו-Git.

* **\`pwd\` (Print Working Directory)**: פקודה זו מציגה את הנתיב המלא של הספרייה הנוכחית שבה המשתמש נמצא. לדוגמה, אם אתה נמצא בתיקיית המסמכים שלך, \`pwd\` עשויה להחזיר \`/Users/YourUsername/Documents\` (ב-macOS/Linux) או \`C:\\Users\\YourUsername\\Documents\` (ב-Windows).

* **\`ls\` (List Directory Contents)**: פקודה זו מפרטת את הקבצים והספריות בתיקייה הנוכחית.
    * דוגמה: \`ls\` יציג: \`file1.txt folderA image.png\`
    * \`ls -a\`: מציג גם קבצים נסתרים (המתחילים בנקודה). לדוגמה, \`ls -a\` עשוי להציג: \`.git .gitignore file1.txt folderA\`
    * \`ls -l\`: מציג מידע מפורט יותר, כולל הרשאות, בעלים, גודל ותאריך שינוי.
    * \`ls -la\`: משלב את התצוגה המפורטת עם הצגת קבצים נסתרים.
    * \`ls -R\`: מפרט פריטים בתוך תיקיות משנה באופן רקורסיבי.
    * \`ls -C\`: מציג תוכן בסגנון רב-עמודי (macOS).
    * \`ls -F\`: מוסיף סמלים (/ לתיקיות, * לקבצים הפעלה, @ לקישורים סימבוליים) (macOS).
    * \`ls -S\`: ממיין קבצים ותיקיות לפי גודל (macOS).
    * \`ls -lt\`: מפרט קבצים בפורמט ארוך, ממוינים לפי זמן שינוי (החדשים ביותר ראשונים) (macOS).
    * \`ls -lh\`: מציג גודל קבצים בפורמט קריא לאדם (KB, MB, GB) (macOS).

* **\`cd\` (Change Directory)**: פקודה זו משמשת למעבר בין ספריות.
    * \`cd [dirname]\`: מעבר לספרייה ספציפית. לדוגמה, אם אתה בתיקיית הבית שלך ויש לך תיקייה בשם \`Projects\`, הקלד: \`cd Projects\`
    * \`cd\`: חזרה לספריית הבית של המשתמש.
    * \`cd ~\`: זהה ל-\`cd\`, מעבר לספריית הבית.
    * \`cd ..\`: מעבר לספריית האב (רמה אחת למעלה). אם אתה ב-\`/Projects/MyProject\`, הקלד \`cd ..\` כדי לעבור ל-\`/Projects\`.
    * \`cd -\`: מעבר לספרייה הקודמת שבה שהה המשתמש.
    * \`cd /\`: מעבר לספריית השורש של מערכת הקבצים.
    * **נתיבים יחסיים (Relative Paths)**: מתחילים מהספרייה הנוכחית. לדוגמה, \`cd ../../usr/lib\` יעלה שתי רמות למעלה ואז יכנס לתיקייה \`usr/lib\`.
    * **נתיבים מוחלטים (Absolute Paths)**: מציינים את המיקום המלא החל מספריית השורש (\`/\`) או ספריית הבית (\`~\`). לדוגמה, \`cd /Users/YourUsername/Documents\` או \`cd ~/Documents\`.

שליטה איתנה ביסודות ניווט אלו חיונית למניעת טעויות נפוצות, כגון "הליכה לאיבוד" בטרמינל או ביצוע פעולות בספרייה שגויה.

**טבלה: פקודות ניווט חיוניות בטרמינל (בין מערכות הפעלה)**

| פקודה | תיאור/פונקציה | אפשרויות נפוצות | דוגמת שימוש | מערכת הפעלה רלוונטית |
| :---- | :------------ | :-------------- | :---------- | :-------------------- |
| \`pwd\` | מציג את הנתיב המלא של הספרייה הנוכחית | \`-L\`, \`-P\` | \`pwd\` | לינוקס/macOS, Windows |
| \`ls\` | מפרט תוכן ספרייה (קבצים ותיקיות) | \`-a\` (נסתרים), \`-l\` (מפורט), \`-R\` (רקורסיבי) | \`ls -la\` | לינוקס/macOS |
| \`dir\` | מפרט תוכן ספרייה (קבצים ותיקיות) | \`/w\` (רחב), \`/p\` (עמודים), \`/s\` (רקורסיבי) | \`dir /s\` | Windows |
| \`cd\` | משנה ספרייה | \`[dirname]\`, \`..\` (למעלה), \`~\` (בית), \`-\` (קודמת), \`/\` (שורש) | \`cd Documents\`, \`cd ..\` | לינוקס/macOS, Windows |
        `,
      },
      {
        title: 'ניהול קבצים וספריות: `mkdir`, `touch`, `cp`, `mv`, `rm`',
        content: `
פקודות אלו מאפשרות למשתמשים ליצור, להעתיק, להעביר, לשנות שם ולמחוק קבצים וספריות. חשוב להבין את העוצמה והסכנה הפוטנציאלית של פקודות מסוימות, במיוחד אלו הקשורות למחיקה.

* **\`mkdir\` (Make Directory)**: יוצר ספריות חדשות.
    * תחביר: \`mkdir [dirname]\`. לדוגמה, \`mkdir MyNewProject\` תיצור תיקייה חדשה בשם "MyNewProject".
    * \`mkdir -p [dir1]/[subdir1]\`: יוצר ספריות אב לפי הצורך. לדוגמה, \`mkdir -p project/src/components\` תיצור את התיקיות \`project\`, \`src\` ו-\`components\` אם אינן קיימות.
    * \`mkdir [dir1] [dir2]\`: יוצר מספר ספריות בו-זמנית. לדוגמה, \`mkdir images scripts docs\` תיצור שלוש תיקיות.
    * \`mkdir "My New Folder"\`: יוצר ספריות עם רווחים בשמן. (יש להשתמש במרכאות).
    * מערכות קבצים בלינוקס רגישות לאותיות גדולות/קטנות.

* **\`touch\` (Create File)**: יוצר קבצים ריקים חדשים או מעדכן זמני גישה/שינוי.
    * תחביר: \`touch [filename]\`. לדוגמה, \`touch index.html\` תיצור קובץ HTML ריק.

* **\`cp\` (Copy Files/Directories)**: מעתיק קבצים או ספריות.
    * תחביר: \`cp [source] [destination]\`. לדוגמה, \`cp file.txt new_file.txt\` יעתיק את \`file.txt\` ל-\`new_file.txt\` באותה תיקייה.
    * \`cp -i\`: אינטראקטיבי, מבקש אישור לפני דריסה.
    * \`cp -r\` או \`cp -R\`: רקורסיבי, מעתיק עצי ספריות שלמים. לדוגמה, \`cp -r my_folder backup_folder\` יעתיק את כל \`my_folder\` ותוכנה ל-\`backup_folder\`.
    * \`cp -v\`: מילולי, מציג את התקדמות ההעתקה.
    * ניתן להעתיק ולשנות שם בו-זמנית. לדוגמה, \`cp old_file.txt new_location/renamed_file.txt\`.
    * ניתן להעתיק מספר קבצים לספרייה. לדוגמה, \`cp file1.txt file2.txt my_folder/\`.

* **\`mv\` (Move/Rename Files/Directories)**: מעביר קבצים/ספריות או משנה את שמם.
    * תחביר: \`mv [source] [destination]\`. לדוגמה, \`mv old_location/file.txt new_location/\` יעביר את הקובץ.
    * \`mv -i\`: אינטראקטיבי, מבקש אישור לפני דריסה.
    * \`mv -v\`: מילולי.
    * שינוי שם: \`mv oldname.txt newname.txt\`.

* **\`rm\` (Remove Files/Directories)**: מוחק קבצים לצמיתות.
    * תחביר: \`rm [filename]\`. לדוגמה, \`rm unwanted.txt\`.
    * \`rm -i\`: אינטראקטיבי, מבקש אישור.
    * \`rm -r\` או \`rm -R\`: רקורסיבי, מוחק ספריות ותוכן. **אזהרה**: פעולה זו מסוכנת ובלתי הפיכה. לדוגמה, \`rm -r old_folder/\` ימחק את התיקייה ותוכנה.
    * \`rm -f\`: כפייה, מוחק ללא אישור. **זהירות יתרה**: \`rm -rf /\` יכול למחוק את כל המערכת.
    * \`rmdir [dirname]\`: מוחק ספריות *ריקות* בלבד. בטוח יותר מ-\`rm -r\` עבור ספריות ריקות.

הפקודות הללו מדגישות את העובדה שפעולות CLI הן לרוב בלתי הפיכות, בניגוד לממשקים גרפיים עם פחי אשפה. יש צורך בגישה של "בדוק פעמיים לפני ביצוע" ולחזק את חשיבות בקרת הגרסאות (Git) כרשת ביטחון לשינויים שבוצעו, גם אם מחיקות מקומיות הן קבועות.

**טבלה: פקודות ניהול קבצים חיוניות בטרמינל (בין מערכות הפעלה)**

| פקודה | תיאור/פונקציה | אפשרויות נפוצות | דוגמת שימוש | מערכת הפעלה רלוונטית | הערות זהירות |
| :---- | :------------ | :-------------- | :---------- | :-------------------- | :------------ |
| \`mkdir\` | יוצר ספריות חדשות | \`-p\` (אב), \`[dir1][dir2]\` (מרובות) | \`mkdir -p project/src\` | לינוקס/macOS, Windows | |
| \`touch\` | יוצר קובץ ריק / מעדכן זמנים | | \`touch newfile.txt\` | לינוקס/macOS | |
| \`cp\` | מעתיק קבצים/ספריות | \`-i\` (אינטראקטיבי), \`-r\` (רקורסיבי), \`-v\` (מילולי) | \`cp -i file.txt backup/\` | לינוקס/macOS, Windows | |
| \`mv\` | מעביר/משנה שם קבצים/ספריות | \`-i\` (אינטראקטיבי), \`-v\` (מילולי) | \`mv oldname.txt newname.txt\` | לינוקס/macOS, Windows | |
| \`rm\` | מוחק קבצים/ספריות לצמיתות | \`-i\` (אינטראקטיבי), \`-r\` (רקורסיבי), \`-f\` (כפייה) | \`rm -rf old_folder/\` | לינוקס/macOS, Windows | **סכנה: מחיקה בלתי הפיכה!** |
| \`rmdir\` | מוחק ספריות ריקות | | \`rmdir empty_dir\` | לינוקס/macOS, Windows | בטוח יותר מ-\`rm -r\` לריקים |
| \`del\` | מוחק קבצים | | \`del oldfile.txt\` | Windows | |
| \`ren\` | משנה שם קובץ/ספרייה | | \`ren oldname newname\` | Windows | |
        `,
      },
      {
        title: 'הצגת תוכן קבצים: `cat`, `less`, `head`, `tail`',
        content: `
פקודות אלו מאפשרות לא רק צפייה בנתונים, אלא גם שליטה על זרימתם ושינויים בסביבת הטרמינל, מה שמהווה בסיס חיוני לבניית זרימות עבודה מורכבות וסקריפטים אוטומטיים.

* **\`cat\` (Concatenate)**: מציג את כל תוכן הקובץ למסך. לדוגמה, \`cat my_document.txt\` יציג את כל הטקסט שבקובץ. יכול גם ליצור קבצים חדשים (\`cat > [filename]\`) או להוסיף לתוכן קבצים קיימים (\`cat >> [filename]\`).
    * \`cat -n [filename]\`: מציג מספרי שורות.
    * \`tac\`: מציג תוכן בסדר הפוך.

* **\`less\`**: מציג תוכן קבצים עמוד אחר עמוד, ומאפשר גלילה. שימושי לקבצים גדולים.
    * ניווט: מקש רווח לעמוד הבא, \`J\`/חץ למטה לשורה הבאה, \`K\`/חץ למעלה לשורה קודמת.
    * חיפוש: \`/\` ואחריו מונח החיפוש.
    * יציאה: \`q\`.

* **\`echo\`**: מציג הודעות או כותב/מוסיף טקסט לקבצים.
    * \`echo "Hello World" > [filename]\`: יוצר/דורס קובץ עם הטקסט "Hello World".
    * \`echo "Hello World" >> [filename]\`: מוסיף טקסט "Hello World" לקובץ קיים.

* **\`head\`**: מציג את החלק הראשון (ברירת מחדל 10 שורות) של קבצים.
    * \`head -n 5 [filename]\`: מציג 5 שורות ראשונות.

* **\`tail\`**: מציג את החלק האחרון (ברירת מחדל 10 שורות) של קבצים.
    * \`tail -n 5 [filename]\`: מציג 5 שורות אחרונות.

* **\`type\` (Windows)**: מציג תוכן קבצים.

* **ניתוב מחדש (\`>\` ו-\`>>\`) וצינורות (\`|\`)**:
    * \`>\`: שומר פלט פקודה לקובץ חדש, דורס אם קיים. לדוגמה, \`ls > file_list.txt\` ישמור את רשימת הקבצים בקובץ חדש.
    * \`>>\`: מוסיף פלט פקודה לקובץ קיים. לדוגמה, \`echo "New line" >> existing_file.txt\` יוסיף שורה חדשה לסוף הקובץ.
    * \`|\`: מעביר פלט של פקודה אחת כקלט לפקודה אחרת (לדוגמה, \`ls -l | less\` יציג את רשימת הקבצים המפורטת בעמודים). הבנת ניתוב מחדש וצינורות היא יסודית לבניית זרימות עבודה וסקריפטים אוטומטיים מורכבים יותר, מכיוון שהיא מאפשרת שרשור פקודות לעיבוד נתונים עוצמתי.
        `,
      },
      {
        title: 'הבנת מעטפות שונות: Bash, Zsh, PowerShell',
        content: `
מעטפת (shell) היא תוכנית המתווכת בין המשתמש למערכת ההפעלה, ואחראית על ניתוח פקודות, ניהול סביבה וביצוע תהליכים. הבחירה במעטפת מסוימת אינה רק העדפה אישית; היא משפיעה על יעילות זרימת העבודה, ניידות סקריפטים ושימוש במשאבי המערכת.

* **Bash (Bourne Again Shell)**:
    * קל משקל, מהיר ותואם באופן נרחב.
    * ברירת המחדל ברוב מערכות לינוקס ו-macOS לפני Catalina.
    * תואם POSIX.
    * יכולות סקריפטים חזקות, טוב לאוטומציה.
    * התאמה אישית ותמיכה בתוספים מוגבלות.
    * השלמה אוטומטית בסיסית. בשל תאימותו ל-POSIX, סקריפטי Bash ניתנים להעברה בקלות כמעט לכל מערכות יוניקס.

* **Zsh (Z Shell)**:
    * מתוחכם יותר, אידיאלי להתאמה אישית ואינטראקטיביות.
    * ברירת המחדל ב-macOS מאז Catalina (2019).
    * משלב תכונות מ-Korn Shell (ksh) ו-C shell (csh).
    * השלמה אוטומטית מתקדמת והיסטוריית פקודות (ממשק דמוי תפריט, תיקון שגיאות הקלדה, הצעות).
    * תמיכה נרחבת בתוספים וערכות נושא (לדוגמה, Oh My Zsh).
    * הדגשת תחביר.
    * יכול להיות כבד יותר עם תוספים רבים.

* **PowerShell**:
    * סביבה נפוצה:.NET,.NET Framework.
    * מעטפת כניסה/סקריפט ברירת מחדל ב-Windows 7, 8, 10, Server 2008.
    * CLI גרפי.
    * תומך בעכבר וב-Unicode.
    * תחביר פקודות שונה בהשוואה למעטפות דמויות יוניקס.

ההשוואה בין Bash ל-Zsh מציגה פשרה: Bash מתעדף "פשטות וניידות" ו"מהירות", מה שהופך סקריפטים לניידים בקלות בין מערכות יוניקס בזכות תאימות POSIX. Zsh, לעומת זאת, מציע "התאמה אישית מתקדמת" ו"אינטראקטיביות", אך יכול להיות "כבד עם תוספים רבים" וחסר קבלה אוניברסלית של POSIX. PowerShell מייצג פרדיגמה שונה לחלוטין עבור Windows. עבור משתמשים חדשים, ברירת המחדל עשויה להספיק, אך משתמשים מתקדמים יכולים לבחור בהתבסס על הצורך שלהם בהתאמה אישית (Zsh) לעומת אמינות סקריפטים בין פלטפורמות (Bash).

**טבלה: השוואת תכונות בין Bash ל-Zsh**

| תכונה | Bash | Zsh |
| :---- | :--- | :-- |
| הדגשת תחביר | לא, CLI בסיסי | כן |
| יכולות סקריפטים | עוצמתי | מציע יותר התאמה אישית לחווית סקריפטים אינטואיטיבית |
| התאמה אישית | מוגבלת מאוד | מתקדמת |
| מהירות | מהיר מאוד | מהיר, אך יכול להאט עם עומס תוספים |
| ברירת מחדל ב-Linux | כן | לא (למעט Kali Linux) |
| ברירת מחדל ב-macOS | לא (הוחלף מ-Catalina) | כן (מאז Catalina) |
| תאימות POSIX | כן, 100% | לא, אך עדיין מותקן כמעטפת משנית |
| השלמה אוטומטית | בסיסית | מתקדמת |
| תמיכה בתוספים | מוגבלת | מתקדמת (באמצעות Oh My Zsh) |
        `,
      },
    ],
  },
  {
    id: 'git-fundamentals',
    title: 'III. יסודות Git: מעקב אחר הקוד באופן מקומי',
    icon: <GitBranch className="w-5 h-5" />,
    sections: [
      {
        title: 'זרימת העבודה ב-Git: Modified, Staged, Committed',
        content: `
Git מציג מודל ייחודי לניהול שינויים, המבוסס על שלושה מצבים עיקריים של קבצים ושלושה אזורים מרכזיים בפרויקט. מודל זה מאפשר למפתחים שליטה עדינה על מה נכלל בכל שינוי (commit), ובכך מקדם היסטוריית קוד נקייה וקריאה, החיונית לביקורת קוד, ניפוי באגים ושיתוף פעולה יעיל.

**שלושה מצבים עיקריים של קבצים:**
* **Modified (שונה)**: קובץ שונה אך טרם נשמר במאגר הנתונים.
* **Staged (מוכן לשינוי)**: קובץ שונה שסומן לכלול בתמונת המצב הבאה של השינוי. זהו אזור ביניים (אזור ה-staging או ה-index) שבו ניתן לעצב ולסקור שינויים לפני ביצועם.
* **Committed (נשמר)**: הנתונים נשמרו בבטחה במאגר הנתונים המקומי (ספריית ה-Git). Git לוקח "תמונה" או "צילום בזק" של הקבצים ברגע זה.

**שלושה אזורים עיקריים בפרויקט Git:**
* **Working Tree (ספריית עבודה)**: עותק יחיד של גרסה אחת של הפרויקט, שבו הקבצים ממוקמים בדיסק לשימוש או שינוי.
* **Staging Area (אזור ההכנה/Index)**: קובץ (בדרך כלל בספריית \`.git\`) המאחסן מידע על מה ייכלל בשינוי הבא. אזור זה מאפשר להכין לשינוי *חלקים* מקובץ ששונה.
* **Git Directory (ספריית Git / תיקיית.git)**: המקום שבו Git מאחסן מטא-נתונים ומאגר אובייקטים של הפרויקט; החלק החשוב ביותר, המועתק במהלך \`git clone\`.

**שלבי זרימת העבודה הבסיסית ב-Git:**
1.  שינוי קבצים בספריית העבודה.
2.  הכנה סלקטיבית של שינויים לאזור ה-staging (\`git add\`).
3.  ביצוע שינוי (commit) של הקבצים שהוכנו, ושמירת תמונת המצב לצמיתות בספריית ה-Git (\`git commit\`).

מודל זה של "שלושה מצבים" ו"שלושה אזורים" הוא בחירה עיצובית מכוונת המעניקה למפתחים שליטה עדינה על מה שנשמר. היכולת "להכין באופן סלקטיבי" ואף להכין "חלקים מקובץ ששונה" היא יכולת חזקה המונעת שינויים מונוליטיים ובלתי ניתנים לביקורת. תהליך זה מקדם היסטוריית שינויים נקייה ומשמעותית יותר, ומאפשר למפתחים לחדד את שינוייהם ולקבץ שינויים קשורים, מה שחיוני לביקורת קוד יעילה, ניפוי באגים והבנת התפתחות הפרויקט.

**טבלה: מצבי קבצים ואזורי פרויקט ב-Git**

| מצב קובץ | תיאור | אזור Git מקביל | פקודה(ות) מפתח |
| :------- | :--- | :-------------- | :------------- |
| שונה (Modified) | הקובץ שונה אך טרם נשמר במאגר הנתונים | Working Tree (ספריית עבודה) | עריכת קובץ |
| מוכן לשינוי (Staged) | קובץ שונה שסומן לכלול בתמונת המצב הבאה של השינוי | Staging Area (אזור ההכנה/Index) | \`git add\` |
| נשמר (Committed) | הנתונים נשמרו בבטחה במאגר הנתונים המקומי | Git Directory (ספריית Git) | \`git commit\` |
        `,
      },
      {
        title: 'אתחול מאגר מקומי: `git init`',
        content: `
\`git init\` היא הפקודה הראשונה והבסיסית ביותר ליצירת מאגר Git מקומי.
* **מטרה**: פקודה זו מאתחלת מאגר Git חדש בספרייה הנוכחית, ויוצרת תיקיית \`.git\` נסתרת המאחסנת את כל היסטוריית הפרויקט.
* **פקודה**: \`git init\`
    * דוגמה: כדי לאתחל מאגר חדש בתיקייה בשם \`my_new_project\`, נווט לתיקייה זו בטרמינל והקלד: \`git init\`
* **ענף ראשוני**: כברירת מחדל, הענף הראשוני נקרא בדרך כלל \`master\` או \`main\`. החל מגרסה Git 2.28.0 ואילך, ניתן להגדר את שם ענף ברירת המחדל באמצעות \`git init -b main\`.
* **זרימת עבודה**: זוהי בדרך כלל הפעולה הראשונה בעת התחלת פרויקט חדש באופן מקומי.

החשיבות של \`git init\` טמונה ביכולתה להפוך ספרייה רגילה לישות מנוהלת גרסאות. זהו הרגע שבו הפרויקט רוכש "זיכרון" ויכולת לעקוב אחר שינויים באופן מקומי, ללא תלות בשרת מרוחק כלשהו. יכולת זו לאתחל מאגר באופן מקומי מאפשרת למפתחים להתחיל לעקוב אחר שינויים באופן מיידי, גם ללא חיבור לאינטרנט או חשבון GitHub, ובכך מדגישה את התועלת המרכזית של Git עוד לפני שיתוף הפעולה.
        `,
      },
      {
        title: 'הכנת שינויים: `git add` (כולל הכנה חלקית)',
        content: `
לאחר שינוי קבצים בספריית העבודה, השלב הבא הוא להכין אותם לשינוי (commit).
* **מטרה**: פקודה זו מסמנת קבצים ששונו כדי לכלול אותם בתמונת המצב הבאה של השינוי. היא מעבירה שינויים מספריית העבודה לאזור ה-staging (אזור ההכנה).
* **פקודה**: \`git add <file>\`
    * דוגמה 1: כדי להכין קובץ ספציפי בשם \`index.html\`: \`git add index.html\`
    * דוגמה 2: כדי להכין את כל השינויים (ששונו, נוספו, נמחקו) בספרייה הנוכחית ובספריות המשנה שלה: \`git add .\` או \`git add -A\`
* **הכנה חלקית (Partial Staging)**: אזור ה-staging מאפשר להכין רק חלקים מקובץ ששונה, ובכך מאפשר שינויים אטומיים (atomic commits).
    * דוגמה: אם שינית מספר שורות בקובץ \`app.js\` וברצונך להכין רק חלק מהשינויים: \`git add -p app.js\` (פקודה זו תעבור על השינויים ותשאל אותך אילו חלקים ברצונך להכין).

ההבחנה בין "הכנה" ל"שינוי" ב-Git היא תכונה ייחודית המאלצת מפתחים להחליט במפורש *אילו* שינויים שייכים יחד ליחידה לוגית אחת. זה לא רק עניין של הוספת קבצים; זוהי פעולה של אצירה של תמונת המצב הבאה. תהליך דו-שלבי זה מקדם היסטוריית שינויים נקייה ומשמעותית יותר, ומאפשר למפתחים לחדד את שינוייהם ולקבץ שינויים קשורים, מה שחיוני לביקורת קוד יעילה, ניפוי באגים והבנת התפתחות הפרויקט.
        `,
      },
      {
        title: 'שמירת העבודה: `git commit` (עם הודעות משמעותיות)',
        content: `
לאחר הכנת השינויים, השלב הבא הוא לשמור אותם במאגר ה-Git.
* **מטרה**: פקודה זו שומרת את תמונת המצב שהוכנה באופן קבוע בספריית ה-Git, ובכך מסמנת אבן דרך בציר הזמן של הפרויקט.
* **פקודה**: \`git commit -m "commit message"\`
    * דוגמה 1: \`git commit -m "הוספת כפתור חדש לעמוד הבית"\`
    * דוגמה 2: אם ברצונך לכתוב הודעת commit מרובת שורות, הקלד \`git commit\` (ללא \`-m\`). זה יפתח עורך טקסט ברירת מחדל (כמו Vim או Nano) שבו תוכל לכתוב את ההודעה.
    * \`git commit --amend\`: משנה את ה-commit האחרון.
        * דוגמה: אם ביצעת commit ושכחת לכלול קובץ, או שיש שגיאת כתיב בהודעה, הוסף את הקובץ (\`git add forgotten_file.js\`) ואז הקלד \`git commit --amend\`. זה יעדכן את ה-commit האחרון במקום ליצור חדש.
* **הודעות שינוי (Commit Messages)**: חיוניות למעקב אחר שינויים ולמתן הקשר לצוות.
    * שיטות מומלצות: שימוש בלשון ציווי (לדוגמה, "הוסף תכונה" במקום "הוספתי תכונה"), סיכום תמציתי (פחות מ-50 תווים), גוף מפורט במידת הצורך.
    * ניתן להשתמש בתבנית הודעת שינוי גלובלית.

שינוי הוא תמונת מצב, אך הודעת השינוי היא הנרטיב. הדגש על "הודעות שינוי משמעותיות" ו"שינויים אטומיים" הופך סדרת שינויים טכניים להיסטוריה קריאה. הודעות שינוי טובות חיוניות לשיתוף פעולה בצוות, ניפוי באגים ותחזוקת פרויקטים. הן מאפשרות למפתחים להבין במהירות *מדוע* שינוי בוצע, לא רק *מה* השתנה, וזה קריטי לפיתוח עתידי ולפתרון בעיות.
        `,
      },
      {
        title: 'בדיקת המאגר: `git status`, `git log`, `git diff`',
        content: `
פקודות אלו מהוות "ערכת כלים פורנזית" להבנת מצב והיסטוריית בסיס הקוד. הן מאפשרות למפתחים לענות ביעילות על שאלות כמו "מה השתנה?", "מי שינה זאת?" ו"מדוע זה השתנה?".

* **\`git status\`**: מציג את מצב השינויים כבלתי נתונים למעקב (untracked), שונו (modified) או הוכנו (staged).
    * הפלט כולל: שם הענף הנוכחי, שינויים מוכנים ל-commit, קבצים ששונו אך לא הוכנו, וקבצים לא נתונים למעקב.
    * דוגמה:
        \`\`\`
        On branch main
        Your branch is up to date with 'origin/main'.

        Changes to be committed:
          (use "git restore --staged <file>..." to unstage)
            new file:   new_feature.js
            modified:   index.html

        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
            modified:   styles.css

        Untracked files:
          (use "git add <file>..." to include in what will be committed)
            temp_notes.txt
        \`\`\`
    * \`git status --short\`: פלט תמציתי.
    * \`git status -u no\`: מסתיר קבצים לא נתונים למעקב.

* **\`git log\`**: מציג את היסטוריית השינויים (commits).
    * מציג: הודעת שינוי, מחבר, חותמת זמן, גיבוב שינוי.
    * דוגמה:
        \`\`\`
        commit f7b3a9c (HEAD -> main, origin/main)
        Author: John Doe <john.doe@example.com>
        Date:   Mon May 27 10:00:00 2024 +0300

            Adding user authentication feature

        commit a1b2c3d
        Author: Jane Smith <jane.smith@example.com>
        Date:   Fri May 24 15:30:00 2024 +0300

            Fix: Corrected typo in footer
        \`\`\`
    * \`git log --oneline\`: כל שינוי בשורה אחת.
    * \`git log --graph\`: מצייר גרף מבוסס טקסט של ההיסטוריה.
    * \`git log --decorate\`: מציג שמות ענפים/תגים.
    * \`git log --stat\`: כולל סטטיסטיקות על שינויי קבצים (הוספות/מחיקות).
    * \`git log -p\`: מציג את כל ה-patch (השינויים בפועל).
    * \`git log --author="Name"\` / \`--since="Date"\` / \`-- path/to/file\`: מסנן שינויים.
    * \`git log --branches=*\`: מציג את כל השינויים בכל הענפים.

* **\`git diff\`**: מציג הבדלים בין מצבים שונים של קבצים.
    * \`git diff\`: משווה את ספריית העבודה לאזור ה-staging (שינויים לא מוכנים).
    * \`git diff --staged\` או \`git diff --cached\`: משווה את אזור ה-staging לשינוי האחרון (שינויים מוכנים).
    * \`git diff HEAD\`: ההבדל הכולל בין קבצי העבודה לשינוי האחרון.
    * \`git difftool\`: פותח כלי השוואה ויזואלי.

* **\`git shortlog\`**: מסכם את פלט \`git log\`, מקבץ שינויים לפי מחבר. שימושי להערות שחרור.

* **\`git blame\`**: מציג מטא-נתונים של מחבר עבור שורות ספציפיות בקובץ. שימושי למציאת מי שינה לאחרונה שורה ומתי.

**טבלה: פרשנות פלט \`git status\`**

| סעיף פלט/סמל | משמעות | דוגמה | פעולה מוצעת הבאה |
| :----------- | :----- | :---- | :---------------- |
| \`On branch <branch-name>\` | שם הענף הנוכחי | \`On branch main\` | המשך עבודה על ענף זה |
| \`Changes to be committed\` | קבצים שהוכנו ומוכנים ל-commit | \`new file: file.txt\` | \`git commit -m "..."\` |
| \`Changes not staged for commit\` | קבצים ששונו אך לא הוכנו | \`modified: index.html\` | \`git add index.html\` |
| \`Untracked files\` | קבצים חדשים ש-Git לא עוקב אחריהם | \`?? temp.txt\` | \`git add temp.txt\` או הוספה ל-\`.gitignore\` |
| \`nothing to commit, working tree clean\` | אין שינויים בספריית העבודה או באזור ה-staging | \`nothing to commit\` | המשך פיתוח |
        `,
      },
    ],
  },
  {
    id: 'github-connection',
    title: 'IV. התחברות ל-GitHub: שיתוף פעולה ומאגרים מרוחקים',
    icon: <Github className="w-5 h-5" />,
    sections: [
      {
        title: 'יצירת חשבון GitHub',
        content: `
יצירת חשבון GitHub היא צעד פשוט, אך היא מהווה שער הכניסה למערכת האקולוגית השיתופית של פיתוח קוד. הדגש המיידי על אימות דו-שלבי (2FA) כבר בשלב זה מדגיש שאבטחה אינה מחשבה שנייה, אלא דרישה בסיסית מראשית הדרך ב-GitHub.

* **תהליך**:
    1.  יש לפתוח את \`https://github.com\` או \`https://github.com/join\` בדפדפן.
    2.  יש להזין כתובת אימייל, ליצור סיסמה ושם משתמש.
    3.  יש לאמת את החשבון (באמצעות פאזל וקוד השקה שנשלח לאימייל).
    4.  שאלות התאמה אישית אופציונליות.
    5.  יש לבחור בחשבון חינם או לדלג על ההתאמה אישית.
* **שיטה מומלצת**: יש להגדיר אימות דו-שלבי (2FA) באופן מיידי. ארגונים מסוימים אף דורשים זאת.

שלב זה אינו רק עניין של גישה; הוא עוסק בביסוס זהות מאובטחת בסביבה ציבורית ושיתופית, ובכך מכין את הקרקע לאינטראקציה אחראית עם קוד משותף.
        `,
      },
      {
        title: 'הגדרת מאגר ה-GitHub הראשון שלך',
        content: `
יצירת מאגר ב-GitHub (מאגר מרוחק) היא המקבילה ל-\`git init\` (מאגר מקומי). שלב זה מבסס את ה"מרכז המרכזי" לשיתוף פעולה, גם במערכת מבוזרת. האפשרות לאתחל עם קובץ README היא שיטה מומלצת לתיעוד ובהירות הפרויקט.

* **דרך אתר GitHub**:
    1.  בפינה הימנית העליונה, יש לבחור \`+\` ולאחר מכן ללחוץ על \`New repository\`.
    2.  יש להקליד שם (לדוגמה, "hello-world").
    3.  אופציונלי: הוסף תיאור, בחר נראות (ציבורי/פרטי).
    4.  מומלץ: \`Initialize this repository with a README\`.
    5.  יש ללחוץ על \`Create repository\`.
* **דרך GitHub CLI (\`gh repo create\`)**:
    1.  יש לנווט לספרייה המקומית הרצויה.
    2.  יש להריץ \`gh repo create\`.
    3.  יש לעקוב אחר ההנחיות (לבחור "Create a new repository on GitHub from scratch", להזין שם, לבחור נראות).
    4.  יש לאשר שיבוט מקומי.
* **דרך GitHub Desktop**:
    1.  יש ללחוץ על \`Create a New Repository on your Hard Drive\`.
    2.  יש למלא את השדות (שם, תיאור, נתיב מקומי) ולבחור אפשרויות.
    3.  מומלץ: \`Initialize this repository with a README.md\`.
    4.  אופציונלי: Git ignore, רישיון.
    5.  יש ללחוץ על \`Create repository\`.

זהו השלב שבו זרימת העבודה המקומית של Git מתחברת לפלטפורמת שיתוף הפעולה הגלובלית. מאגר מרוחק מאותחל היטב עם קובץ README מקל על הצטרפות תורמים חדשים ומספק הקשר מיידי.
        `,
      },
      {
        title: 'שיבוט מאגר מרוחק: `git clone` (HTTPS מול SSH)',
        content: `
\`git clone\` היא הפקודה המרכזית להורדת עותק של מאגר קיים. בחירת הפרוטוקול (HTTPS או SSH) משפיעה על האבטחה, הנוחות וזרימת העבודה.

* **מטרה**: יוצר עותק מקומי של מאגר מרוחק קיים, כולל כל הקבצים, ההיסטוריה והענפים.
* **פקודה**: \`git clone <repository-url>\`
    * דוגמה: \`git clone https://github.com/your-username/your-repo.git\` (עבור HTTPS)
    * דוגמה: \`git clone git@github.com:your-username/your-repo.git\` (עבור SSH)
* **חיבור מרוחק אוטומטי**: שיבוט יוצר באופן אוטומטי חיבור מרוחק בשם "origin" המצביע חזרה למאגר המקורי.
* **פרוטוקולי HTTPS מול SSH**: שני פרוטוקולים עיקריים לשיבוט/אינטראקציה.

    * **HTTPS**:
        * **יתרונות**: קל להגדרה (אין צורך במפתחות מעבר לשם משתמש/סיסמה או PAT), עובד דרך חומות אש/פרוקסי (פורט 443).
        * **אימות**: דורש שם משתמש/סיסמה או Personal Access Token (PAT). GitHub ממליץ על PATs.
        * **חסרונות**: יכול להיות איטי יותר עב תקורה של SSL/TLS, דורש הזנה חוזרת של פרטי אימות או שימוש בעוזרי אימות.
    * **SSH**:
        * **יתרונות**: אבטחה משופרת (קריפטוגרפיה של מפתח ציבורי), פעולות ללא צורך בהזנת פרטי אימות לאחר ההגדרה, בדרך כלל מהיר יותר.
        * **אימות**: משתמש בזוגות מפתחות SSH (מפתח ציבורי/פרטי).
        * **חסרונות**: דורש הגדרה ראשונית של מפתחות SSH הן במחשב המקומי והן ב-GitHub. עלול להיחסם על ידי חומות אש קפדניות (פורט 22).
    * **המלצת GitHub**: תיעוד GitHub ממליץ לעיתים קרובות על SSH על פני HTTPS מטעמי אבטחה וקלות שימוש.

* **\`git clone --bare\`**: יוצר עותק ללא ספריית עבודה (ללא קבצים ניתנים לעריכה), רק נתוני \`.git\`. משמש למאגרים מרכזיים בצד השרת.
* **\`git clone --mirror\`**: משכפל באופן מרומז, משקף את כל המאגר כולל כל ההפניות וההגדרות. משמש לגיבויים או הגירה.
* **Forking מול Cloning**:
    * **Cloning**: יוצר עותק מקומי של מאגר. ניתן לדחוף שינויים חזרה למאגר המקורי אם יש הרשאות. נפוץ לשיתוף פעולה בצוות על פרויקט יחיד.
    * **Forking**: יוצר *עותק אישי של מאגר של מישהו אחר בחשבון GitHub שלך* (עותק מרוחק). עותק זה עצמאי. לאחר מכן משכפלים את *ה-fork שלך* באופן מקומי. שינויים נדחפים ל-fork שלך, ו-Pull Request מוגש למאגר המקורי. אידיאלי לתרומה לפרויקטי קוד פתוח שבהם אין לך גישת כתיבה ישירה.

הבחירה בין HTTPS ל-SSH אינה שרירותית; זוהי פשרה בין נוחות הגדרה ראשונית (HTTPS) לבין אבטחה ויעילות זרימת עבודה לטווח ארוך (SSH). המעבר מאימות מבוסס סיסמה ל-PATs עבור HTTPS והאבטחה המובנית של מפתחות SSH מצביעים על מגמה רחבה יותר בתעשייה לעבר שיטות אימות חזקות יותר. משתמשים צריכים לבחור בשיטה המתאימה ביותר לצרכי האבטחה וזרימת העבודה שלהם, עם המלצה חזקה ל-SSH עבור משתמשים תכופים ול-PATs עבור HTTPS.

**טבלה: HTTPS מול SSH עבור פעולות Git**

| תכונה | HTTPS | SSH |
| :---- | :---- | :-- |
| שיטת אימות | שם משתמש/סיסמה או PAT | קריפטוגרפיה של מפתח ציבורי (זוג מפתחות) |
| רמת אבטחה | טובה, אך דורשת ניהול PATs | גבוהה יותר, ללא צורך בסיסמאות |
| הגדרה | קלה, ללא צורך ביצירת מפתחות | דורשת יצירה והגדרה של מפתחות SSH |
| הנחיות אימות | דורש הזנה חוזרת של פרטי אימות או שימוש בעוזרי אימות | פעולות ללא צורך בפרטי אימות לאחר ההגדרה |
| תאימות חומת אש/פרוקסי | עובד היטב (פורט 443) | עלול להיחסם (פורט 22) |
| ביצועים | יכול להיות איטי יותר עב תקורה של SSL/TLS | בדרך כלל מהיר יותר |
| המלצת GitHub | שימושי, אך מומלץ PATs עם 2FA | מומלץ לאבטחה ונוחות |
        `,
      },
      {
        title: 'אבטחת אסימוני גישה (Tokens) ופרטי אימות',
        content: `
**חשיבות אי-שיתוף אסימוני גישה (Personal Access Tokens - PATs) ופרטי אימות:**

אסימוני גישה (PATs) הם מפתחות סודיים המאפשרים לך לגשת למאגרי GitHub שלך דרך הטרמינל או כלים אחרים, ללא צורך להזין את שם המשתמש והסיסמה שלך בכל פעם. הם מעניקים הרשאות ספציפיות (לדוגמה, קריאה בלבד, כתיבה, ניהול מאגרים) ויכולים להיות בעלי תאריך תפוגה.

**מדוע אסור לשתף אותם?**

* **גישה בלתי מורשית:** שיתוף PATs זהה לשיתוף הסיסמה שלך. כל מי שיש לו את ה-PAT יכול לבצע פעולות בחשבון ה-GitHub שלך בהתאם להרשאות שהוענקו לאסימון. זה כולל דחיפת קוד זדוני, מחיקת מאגרים, או גישה למידע רגיש.
* **הפרת אבטחה:** אם ה-PAT נחשף (לדוגמה, נשמר בקוד גלוי, נשלח באימייל לא מאובטח, או נכלל ביומני מערכת), התוקפים יכולים לנצל אותו.
* **אחריות:** אתה אחראי לכל פעולה שתבוצע באמצעות ה-PAT שלך. אם הוא נחשף, זה עלול להוביל לבעיות אבטחה חמורות עבור הפרויקטים שלך ושל הצוות שלך.

**שיטות מומלצות לאבטחת PATs:**

* **היקף הרשאות מינימלי (Principle of Least Privilege):** צור PATs עם ההרשאות המינימליות הנדרשות למשימה ספציפית. לדוגמה, אם אתה רק צריך לקרוא מאגרים, אל תעניק הרשאות כתיבה.
* **תאריך תפוגה:** הגדר תאריך תפוגה קצר ככל האפשר עבור ה-PATs שלך. זה מפחית את הסיכון במקרה שהם נחשפים.
* **אחסון מאובטח:** לעולם אל תשמור PATs ישירות בקוד המור שלך. השתמש במשתני סביבה, מנהלי סודות (secret managers), או מערכות ניהול אישורים (credential managers) כדי לאחסן אותם בצורה מאובטחת.
* **אימות דו-שלבי (2FA):** הפעל 2FA בחשבון ה-GitHub שלך. זה מוסיף שכבת אבטחה נוספת גם אם הסיסמה או ה-PAT שלך נחשפים.
* **ביקורת קבועה:** בקר באופן קבוע את ה-PATs הפעילים שלך ב-GitHub ומחק כל אסימון שאינו בשימוש או שפג תוקפו.
* **הימנע מ-Hardcoding:** לעולם אל תכתוב את ה-PATs שלך ישירות בקבצי קוד או קונפיגורציה שנדחפים למאגר Git.

זכור, אבטחה היא אחריות משותפת. שמירה על אסימוני הגישה שלך מאובטחים היא צעד קריטי בהגנה על הפרויקטים והמידע שלך.
        `,
      },
      {
        title: 'חיבור המאגר המקומי למאגר מרוחק: `git remote add origin`',
        content: `
\`git remote add origin\` היא הפקודה המפורשת שהופכת מאגר מקומי מבודד למשתתף בזרימת עבודה שיתופית ומבוזרת. זהו לחיצת היד בין העולם המקומי לעולם המרוחק, ובלעדיה, פקודות \`git push\` ו-\`git pull\` חסרות משמעות.

* **מטרה**: מקשר את מאגר ה-Git המקומי למאגר מרוחק, בדרך כלל בשם "origin". קישור זה מאפשר לדחוף (push) ולמשוך (pull) שינויים.
* **פקודה**: \`git remote add origin <remote-repository-url>\`
    * דוגמה: אם יצרת מאגר חדש ב-GitHub בשם \`my-new-repo\`, כתובת ה-URL שלו תהיה בערך \`https://github.com/your-username/my-new-repo.git\`. כדי לקשר את המאגר המקומי שלך, הקלד: \`git remote add origin https://github.com/your-username/my-new-repo.git\`
* **אימות**: \`git remote -v\` מפרט את כל המאגרים המרוחקים שהוגדרו ואת כתובות ה-URL שלהם.
    * דוגמה: \`git remote -v\` עשוי להציג:
        \`\`\`
        origin  https://github.com/your-username/my-new-repo.git (fetch)
        origin  https://github.com/your-username/my-new-repo.git (push)
        \`\`\`
* **שינוי כתובת URL מרוחקת**: \`git remote set-url origin <new-url>\`.
    * דוגמה: אם שינית את כתובת ה-URL של המאגר המרוחק שלך, תוכל לעדכן אותה עם: \`git remote set-url origin https://github.com/your-username/new-repo-url.git\`

פקודה זו היא יסודית לכל פיתוח מבוסס צוות, שכן היא מגדירה היכן ישותפו שינויים מקומיים ומהיכן יתקבלו שינויים חיצוניים.
        `,
      },
      {
        title: 'דחיפת שינויים מקומיים ל-GitHub: `git push`',
        content: `
\`git push\` היא הפעולה של הפיכת עבודה מקומית לציבורית. האזהרות לגבי "דריסת שינויים" וקיומם של דגלי \`--force\` מדגישות את האחריות המשמעותית הכרוכה בכך. זו אינה רק פקודה טכנית; יש לה השלכות חברתיות בתוך צוות. הצגת הדגל \`--force-with-lease\` היא תגובה ישירה לסכנות של דחיפה כפויה ללא זהירות, ומדגימה את התפתחות Git לתמיכה בשיתוף פעולה בטוח יותר.

* **מטרה**: מעלה תוכן של מאגר מקומי (שינויים) למאגר מרוחק. מעביר שינויים מענפים מקומיים לענפים מרוחקים.
* **פקודה**: \`git push <remote> <branch>\`
    * דוגמה 1 (נפוץ): \`git push origin main\` ידחוף את השינויים מהענף המקומי \`main\` לענף ה-\`main\` במאגר המרוחק \`origin\`.
    * דוגמה 2: \`git push -u origin <branch-name>\`: מגדיר מעקב upstream עבור הענף, כך שדחיפות/משיכות הבאות יכולות להיות \`git push\`/\`git pull\` ללא ציון \`origin main\` בכל פעם. לדוגמה, \`git push -u origin feature/my-new-feature\` ידחוף את הענף \`feature/my-new-feature\` ל-GitHub ויקבע אותו כענף המעקב. לאחר מכן, תוכל פשוט להשתמש ב-\`git push\`.
* **מיזוגים שאינם Fast-Forward**: Git מונע דחיפות שתוצאתן מיזוגים שאינם fast-forward (כלומר, ההיסטוריה המרוחקת התפצלה מהמקומית). דורש משיכה ומיזוג/rebase תחילה.
* **דחיפה כפויה (\`git push --force\` / \`--force-with-lease\`):** דורסת את היסטוריית הענף המרוחק.
    * **סכנות**: עלולה לדרוס עבודה של אחרים, יוצרת היסטוריה מבלבלת. **יש להימנע משימוש ב-\`--force\` אלא אם כן אתה מבין לחלוטין את ההשלכות ורק במאגרים פרטיים שלך.**
    * **\`--force-with-lease\`**: חלופה בטוחה יותר; מונעת דריסה אם למאגר המרוחק יש שינויים חדשים שאינם קיימים במאגר המקומי. זהו אמצעי בטיחות נוסף.

חלק זה חייב להחדיר זהירות ושיטות עבודה מומלצות לדחיפה, במיוחד במאגרים משותפים, תוך הדגשת תקשורת והבנת המצב המרוחק לפני דחיפת שינויים הרסניים פוטנציאליים. זה מתקשר ישירות לחשיבות אי-שיתוף אסימוני גישה, שכן דחיפות לא זהירות עלולות לחשוף נתונים רגישים.
        `,
      },
      {
        title: 'משיכת שינויים מרוחקים למחשב המקומי: `git pull` (`fetch` + `merge`/`rebase`)',
        content: `
במערכת מבוזרת, \`git pull\` הוא המנגנון לשמירה על לכידות קוד. העובדה שהוא שילוב של \`fetch\` ו-\`merge\`/\`rebase\` חושפת נקודת החלטה קריטית למפתחים: כיצד לשלב שינויים. ההבחנה ה"בטוחה" בין \`fetch\` ל-\`pull\` חשובה למניעת קונפליקטים בלתי צפויים.

* **מטרה**: מאחזר ומוריד תוכן ממאגר מרוחק ומעדכן מיד את המאגר המקומי כדי שיתאים לתוכן זה.
* **שילוב פקודות**: \`git pull\` הוא קיצור דרך ל-\`git fetch\` ואחריו \`git merge\` (ברירת מחדל) או \`git rebase\` (אם הוגדר).
    * \`git fetch\`: מוריד תוכן מרוחק אך *אינו* משנה את מצב המאגר המקומי. נחשב "בטוח".
        * דוגמה: \`git fetch origin\` יוריד את כל השינויים החדשים מ-\`origin\` אך לא ימזג אותם לענף הנוכחי שלך. תוכל לבדוק אותם עם \`git log origin/main\`.
    * \`git merge\`: משלב שינויים שאוחזרו לענף המקומי, ועלול ליצור שינוי מיזוג חדש.
    * \`git rebase\`: מפעיל מחדש שינויים מקומיים על גבי שינויים מרוחקים, ויוצר היסטוריה ליניארית.
* **פקודה**: \`git pull origin main\`
    * דוגמה: \`git pull origin main\` יוריד את השינויים מענף ה-\`main\` המרוחק וימזג אותם לענף ה-\`main\` המקומי שלך.
* **קונפליקטים**: אם שינויים מרוחקים חופפים לשינויים מקומיים שלא נשמרו, המיזוג/rebase עלול להתבטל או להוביל לקונפליקטים.
    * פתרון: אם יש קונפליקטים, Git יסמן את הקבצים המושפעים ותצטרך לפתור אותם ידנית לפני שתמשיך (באמצעות עריכת הקבצים ו-\`git add\` ואז \`git commit\`).
* **סנכרון**: חיוני לשמור על ענף ה-\`main\` המקומי מעודכן לפני התחלת עבודה חדשה.

ביצוע \`git pull\` קבוע (או \`fetch\` + \`rebase\`) הוא שיטה מומלצת למזעור קונפליקטים במיזוג ולהבטחת שהמפתחים עובדים תמיד על בסיס הקוד העדכני ביותר, ובכך מקדם אינטגרציה מתמשכת.
        `,
      },
    ],
  },
  {
    id: 'advanced-concepts',
    title: 'V. מושגי Git מתקדמים וזרימות עבודה',
    icon: <RefreshCcw className="w-5 h-5" />,
    sections: [
      {
        title: 'אסטרטגיות ענפים: יצירה וניהול ענפים: `git branch`, `git checkout`, `git switch`',
        content: `
ענף ב-Git הוא מצביע קל משקל וניתן להזזה, המצביע על שינוי (commit). הוא אינו עותק של ספריית קוד המור, מה שהופך את פעולות יצירת הענפים למהירות כמעט מיידית.

* **הגדרת ענף**: מצביע קל משקל וניתן להזזה ל-commit. אינו עותק של ספריית קוד המור.
* **ענף \`master\`/\`main\`**: שם הענף ברירת המחדל, מצביע על ה-commit האחרון. אינו מיוחד, רק קונבנציונלי.

* **\`git branch\`**:
    * \`git branch <branch-name>\`: יוצר ענף חדש.
        * דוגמה: \`git branch feature/login\` תיצור ענף חדש בשם \`feature/login\`.
    * \`git branch\`: מפרט ענפים מקומיים (הענף הנוכחי מסומן ב-\`*\`).
    * \`git branch -r\`: מפרט ענפים מרוחקים.
    * \`git branch -a\`: מפרט את כל הענפים המקומיים והמרוחקים.
    * \`git branch -d <branch-name>\`: מוחק ענף מקומי (רק אם מוזג).
    * \`git branch -D <branch-name>\`: מוחק ענף מקומי בכוח (ללא קשר למצב המיזוג).

* **\`git checkout\`**: פקודה ותיקה יותר, רב-גונית למעבר בין ענפים, יצירת חדשים, או שחזור קבצים.
    * \`git checkout <branch-name>\`: עובר לענף קיים.
        * דוגמה: \`git checkout develop\` יעבור לענף \`develop\`.
    * \`git checkout -b <new-branch-name>\`: יוצר ועובר לענף חדש.
        * דוגמה: \`git checkout -b bugfix/fix-header\` תיצור ענף חדש ותעבור אליו.
    * \`git checkout -- <file>\`: מבטל שינויים שלא נשמרו בקובץ.
        * דוגמה: \`git checkout -- index.html\` יבטל שינויים לא מוכנים בקובץ \`index.html\`.

* **\`git switch\` (Git 2.23+)**: פקודה חדשה יותר, תוכננה במיוחד לפעולות ענפים, עם בדיקות בטיחות ושימושיות טובות יותר.
    * \`git switch <branch-name>\`: עובר לענף קיים.
    * \`git switch -c <new-branch-name>\`: יוצר ועובר לענף חדש.
    * \`git switch -\`: חוזר לענף הקודם.

* **מצביע \`HEAD\`**: מצביע מיוחד המציין את הענף/ה-commit הנוכחי.

הצגת \`git switch\` כחלופה ל-\`git checkout\` עבור פעולות ענפים היא התפתחות משמעותית. היא מתייחסת ל"עמימות" ו"אובדן נתונים פוטנציאלי אם נעשה שימוש לרעה" הקשורים לפונקציונליות הרחבה של \`git checkout\`. התפתחות זו ב-Git מדגימה שיפור מתמשך לקראת חווית משתמש טובה יותר ובטיחות רבה יותר. בעוד ש-\`git checkout\` נשאר רב-גוני, \`git switch\` מומלץ לניהול ענפים מפורש, ומקדם זרימות עבודה בטוחות וברורות יותר, במיוחד עבור משתמשים חדשים.

**טבלה: \`git checkout\` מול \`git switch\`**

| תכונה | \`git checkout\` | \`git switch\` |
| :---- | :------------- | :----------- |
| מטרה | רב-גוני: מעבר ענפים, יצירת חדשים, שחזור קבצים, בדיקת commits | ייעודי למעבר ענפים ויצירת חדשים |
| רב-גוניות | גבוהה, אך עלולה להיות מבלבלת | ממוקדת, פחות רב-גונית אך ברורה יותר |
| בטיחות | פוטנציאל לאובדן נתונים אם נעשה שימוש לרעה (במיוחד עם קבצים/commits) | בדיקות בטיחות משופרות, מפחית סיכון לאובדן נתונים |
| בהירות | עשוי להיות עמום עב ריבוי שימושים | מטרה ברורה, משפר קריאות והבנה |
| שימוש היסטורי | חלק מכלי ה-Git במשך זמן רב, מוכר למשתמשים מנוסים | חדש יחסית (החל מ-Git 2.23+), פחות מוכר אך מומלץ |
| מקרה שימוש מומלץ | פעולות מורכבות יותר, כמו שחזור קבצים מ-commit ספציפי | ניהול ענפים יומיומי, מעבר בטוח וברור |
        `,
      },
      {
        title: 'אסטרטגיות ענפים: מיזוג ענפים: Fast-forward מול מיזוגים תלת-כיווניים',
        content: `
מיזוג הוא הדרך של Git לשלב היסטוריות מפוצלות יחד. ההבדל המהותי בין \`merge\` ל-\`rebase\` הוא אופן הטיפול בהיסטוריה. \`merge\` משמר את ההיסטוריה המדויקת, כולל נתיבים מפוצלים ו-merge commits. \`rebase\` כותב מחדש את ההיסטוריה כדי ליצור נתיב ליניארי ו"נקי" יותר. הבחנה זו יסודית לבחירת האסטרטגיה הנכונה.

* **מטרה**: משלב שינויים מענף אחד לענף אחר.
* **פקודה**: \`git merge <branch-name>\`. מיזוג מתבצע לתוך הענף *הנוכחי*.
    * דוגמה: אם אתה נמצא בענף \`main\` וברצונך למזג אליו שינויים מענף \`feature/login\`, הקלד: \`git merge feature/login\`
* **מיזוג Fast-Forward**: מתרחש כאשר קיים נתיב ליניארי (אין היסטוריה מפוצלת). Git פשוט מזיז את קצה הענף הנוכחי לקצה הענף היעד, ובכך משלב למעשה היסטוריות ללא יצירת commit מיזוג חדש. מיזוג כזה אינו יכול לייצר קונפליקטים.
* **מיזוג תלת-כיווני (True Merge)**: נדרש כאשר הענפים התפצלו. Git משתמש בשלושה commits (שני קצות הענפים ואב קדמון משותף) כדי ליצור "merge commit" חדש המקשר בין שתי ההיסטוריות.
* **קונפליקטים במיזוג**: מתרחשים כאשר Git אינו יכול לשלב שינויים באופן אוטומטי (אותן שורות קוד שונו בהיסטוריות מפוצלות). דורש התערבות משתמש לפתרון.
        `,
      },
      {
        title: 'אסטרטגיות ענפים: ביצוע Rebase ל-Commits: `git rebase`',
        content: `
* **מטרה**: משלב שינויים מענף אחד לענף אחר על ידי העברת רצף של commits לבסיס commit חדש. כותב מחדש את היסטוריית הפרויקט על ידי יצירת commits חדשים לגמרי עבור כל commit בענף המקורי.
* **פקודה**: \`git rebase <base-branch>\` (לדוגמה, \`git rebase main\`).
    * דוגמה: אם אתה בענף \`feature/login\` וברצונך לעדכן אותו עם השינויים האחרונים מ-\`main\` וליצור היסטוריה ליניארית, הקלד: \`git rebase main\`
* **יתרונות**: יוצר היסטוריית פרויקט נקייה וליניארית לחלוטין על ידי ביטול commits מיזוג מיותרים. שימושי לייעול היסטוריות מורכבות בפרויקטים אישיים.
* **Rebase אינטראקטיבי (\`git rebase -i\`):** מאפשר שינוי commits (איחוד, עריכת הודעות, הסרת commits) תוך כדי העברתם.
    * דוגמה: \`git rebase -i HEAD~3\` יפתח עורך טקסט עם שלושת ה-commits האחרונים שלך, ויאפשר לך לערוך, למחוק או לאחד אותם.
* **סכנות (כלל הזהב)**: **לעולם אל תבצע rebase לענפים ציבוריים** (אלו ששותפו עם אחרים). זה כותב מחדש את ההיסטוריה, וגורם לבלבול וקונפליקטים עבור משתפי פעולה.
* **קונפליקטים**: מציג קונפליקטים commit אחד בכל פעם, פוטנציאלית קל יותר לטיפול מקונפליקטים במיזוג.

הבחירה בין \`merge\` ל-\`rebase\` היא אסטרטגית, ומשפיעה על קריאות היסטוריית הפרויקט ועל מורכבות שיתוף הפעולה. עבור ענפים משותפים, \`merge\` בדרך כלל בטוח יותר, בעוד \`rebase\` חזק לניקוי היסטוריה מקומית ולא משותפת. זה גם מדגיש את חשיבות הסכמות צוותיות על זרימת העבודה.

**טבלה: \`git merge\` מול \`git rebase\`**

| היבט | \`git merge\` | \`git rebase\` |
| :--- | :---------- | :----------- |
| מטרה | שילוב שינויים מענף אחד לאחר תוך שמירה על היסטוריה לא ליניארית | שילוב שינויים תוך יצירת היסטוריה ליניארית ונקייה יותר |
| השפעה על היסטוריה | משמר את ההיסטוריה המקורית, כולל פיצולים ו-merge commits | כותב מחדש את ההיסטוריה על ידי יצירת commits חדשים |
| commit חדש? | כן, יוצר merge commit חדש (במיזוג תלת-כיווני) | לא, מעביר commits קיימים (יוצר commits חדשים עם תוכן זהה אך SHA שונה) |
| פתרון קונפליקטים | מציג את כל הקונפליקטים בבת אחת | מציג קונפליקטים commit אחר commit |
| מקרה שימוש | שילוב תכונות גדולות, ענפים ציבוריים, שמירה על היסטוריה מדויקת | ניקוי היסטוריה מקומית, ייעול commits לפני דחיפה, עבודה על ענפים פרטיים |
| מתי להשתמש | בעבודה על ענפים ציבוריים משותפים, כאשר רוצים לשמר את ההיסטוריה המלאה | בפרויקטים אישיים, או לפני דחיפה לענף מרוחק (אם לא שותף) |
| מתי להימנע | | **לעולם אל תבצע rebase לענפים ציבוריים/משותפים** |
        `,
      },
      {
        title: 'ביטול שינויים וכתיבה מחדש של היסטוריה: תיקון Commits: `git commit --amend`',
        content: `
Git מציע מספר פקודות "ביטול", כל אחת עם השפעות שונות על ההיסטוריה ועל ספריית העבודה. ההבחנה הקריטית היא בין פעולות ש*כותבות מחדש את ההיסטוריה* (\`amend\`, \`reset\`) לבין אלו ש*משמרות את ההיסטוריה* (\`revert\`). האזהרות החוזרות ונשנות לגבי אי-שימוש ב-\`amend\` או \`reset --hard\` על commits ציבוריים מדגישות את ההסכם החברתי של היסטוריה משותפת בפיתוח שיתופי.

#### תיקון Commits: \`git commit --amend\`

* **מטרה**: משנה את ה-commit האחרון על ידי שילוב שינויים מוכנים איתו או עריכת הודעת ה-commit בלבד.
* **מנגנון**: מחליף את ה-commit הישן לחלוטין ב-commit חדש (עם ID SHA-1 חדש).
* **מקרים שימוש**: תיקון שגיאות כתיב בהודעות commit, הוספת קבצים שנשכחו ל-commit האחרון.
    * דוגמה: אם ביצעת \`git commit -m "Added new featur"\` (שגיאת כתיב), תוכל לתקן זאת עם \`git commit --amend -m "Added new feature"\`.
    * דוגמה: אם ביצעת commit ושכחת לכלול קובץ, או שיש שגיאת כתיב בהודעה, הוסף את הקובץ (\`git add forgotten_file.js\`) ואז הקלד \`git commit --amend\`. זה יעדכן את ה-commit האחרון במקום ליצור חדש.
* **זהירות**: יש להימנע מתיקון commits ציבוריים (שכבר נדחפו למאגר משותף) מכיוון שזה כותב מחדש את ההיסטוריה וגורם לבעיות למשתפי פעולה.
        `,
      },
      {
        title: 'ביטול שינויים וכתיבה מחדש של היסטוריה: איפוס שינויים: `git reset --soft`, `--mixed`, `--hard`',
        content: `
* **מטרה**: מבטל שינויים על ידי הזזת ה-\`HEAD\` (הפניית הענף הנוכחי) ל-commit ספציפי. משפיע על אזור ה-staging ו/או ספריית העבודה.
* **\`git reset --soft <commit>\`**: מזיז את ה-\`HEAD\` ל-commit שצוין, אך משאיר את אזור ה-staging וספריית העבודה *ללא שינוי* (השינויים נשארים מוכנים). שימושי להתאמת היסטוריית commits (לדוגמה, הסרת ה-commit האחרון) תוך שמירה על השינויים לביצוע commit מחדש.
    * דוגמה: \`git reset --soft HEAD~1\` יבטל את ה-commit האחרון, אך ישאיר את כל השינויים מוכנים ל-commit מחדש.
* **\`git reset --mixed <commit>\` (ברירת מחדל)**: מזיז את ה-\`HEAD\` ומעדכן את אזור ה-staging כך שיתאים ל-commit שצוין, אך משאיר את ספריית העבודה *ללא שינוי* (השינויים הופכים ללא מוכנים). שימושי לביטול הכנת שינויים תוך שמירה עליהם בספריית העבודה.
    * דוגמה: \`git reset HEAD~1\` (או \`git reset --mixed HEAD~1\`) יבטל את ה-commit האחרון וישאיר את השינויים כקובצי עבודה שאינם מוכנים.
* **\`git reset --hard <commit>\`**: מאפס את ה-\`HEAD\`, אזור ה-staging וספריית העבודה כך שיתאימו ל-commit שצוין. **מבטל לחלוטין את כל השינויים** באזור ה-staging ובספריית העבודה. **זהירות יתרה**: אובדן נתונים הוא קבוע.
    * דוגמה: \`git reset --hard HEAD~1\` ימחק את ה-commit האחרון ואת כל השינויים הקשורים אליו מספריית העבודה שלך.
* **מקרה שימוש**: הטוב ביותר לביטול שינויים *מקומיים, פרטיים* שלא שותפו.
        `,
      },
      {
        title: 'ביטול שינויים וכתיבה מחדש של היסטוריה: ביטול Commits: `git revert`',
        content: `
* **מטרה**: יוצר *commit חדש* המבטל את השינויים שהוצגו על ידי commit ספציפי. הוא *אינו* מסיר את ה-commit המקורי מההיסטוריה.
* **מנגנון**: הופך את השינויים של ה-commit היעד ומוסיף "revert commit" חדש להיסטוריה.
* **יתרונות**: משמר את היסטוריית הפרויקט, מה שהופך אותו ל"בטוח" עבור commits שכבר פורסמו למאגר משותף.
* **מקרה שימוש**: הטוב ביותר לביטול שינויים בענפים *משותפים, ציבוריים*.
    * דוגמה: אם commit מסוים (\`abcdef1\`) הכניס באג לענף ה-\`main\` המשותף, תוכל לבטל אותו בבטחה עם: \`git revert abcdef1\`. זה ייצור commit חדש שמבטל את השינויים של \`abcdef1\`.

בחירת פקודת ה"ביטול" הנכונה היא בעלת חשיבות עליונה לשיתוף פעולה יעיל ולמניעת "גיהנום Git". היא מאלצת מפתחים לשקול האם השינויים שלהם מקומיים ופרטיים (בטוח ל-\`reset\`/\`amend\`) או ציבוריים ומשותפים (דורש \`revert\`).

**טבלה: מצבי \`git reset\` מוסברים**

| מצב | תחביר | השפעה על HEAD | השפעה על אזור ה-Staging | השפעה על ספריית העבודה | מקרה שימוש |
| :-- | :--- | :------------ | :--------------------- | :-------------------- | :---------- |
| \`--soft\` | \`git reset --soft <commit>\` | זז ל-\`<commit>\` | נשאר ללא שינוי (השינויים נשארים מוכנים) | נשאר ללא שינוי | התאמת היסטוריית commits תוך שמירה על השינויים לביצוע commit מחדש |
| \`--mixed\` | \`git reset --mixed <commit>\` | זז ל-\`<commit>\` | מתעדכן כך שיתאים ל-\`<commit>\` (השינויים הופכים ללא מוכנים) | נשאר ללא שינוי | ביטול הכנת שינויים תוך שמירה עליהם בספריית העבודה |
| \`--hard\` | \`git reset --hard <commit>\` | זז ל-\`<commit>\` | מתאפס כך שיתאים ל-\`<commit>\` | מתאפס כך שיתאים ל-\`<commit>\` (כל השינויים נמחקים לצמיתות) | ביטול מוחלט של שינויים וחזרה ל-commit ספציפי |

**טבלה: \`git reset\` מול \`git revert\`**

| היבט | \`git reset\` | \`git revert\` |
| :--- | :---------- | :----------- |
| מטרה | מבטל שינויים על ידי הזזת HEAD ל-commit ספציפי | יוצר commit חדש המבטל את השינויים של commit ספציפי |
| השפעה על היסטוריה | כותב מחדש היסטוריה (מסיר commits מהענף הנוכחי) | משמר היסטוריה (מוסיף commit חדש המבטל את הקודם) |
| commit חדש? | לא (אלא אם משתמשים ב-\`--soft\` ואז מבצעים commit מחדש) | כן, תמיד יוצר commit חדח |
| היקף | ברמת commit או קובץ | רק ברמת commit |
| בטיחות למאגרים משותפים | **לא בטוח** (משנה היסטוריה משותפת, עלול לגרום לקונפליקטים) | **בטוח** (אינו משנה היסטוריה, ניתן לדחוף למאגר משותף) |
| מקרה שימוש | ביטול שינויים *מקומיים, פרטיים* | ביטול שינויים *ציבוריים, משותפים* |
        `,
      },
      {
        title: 'ביטול שינויים וכתיבה מחדש של היסטוריה: שמירה זמנית של שינויים: `git stash`',
        content: `
\`git stash\` אינה עוסקת בביטול או שמירה; היא עוסקת בניהול *עבודה בתהליך* ללא צורך בביצוע commit. יכולת זו מאפשרת מעבר מהיר בין הקשרים, צורך נפוץ בפיתוח זריז שבו מפתחים עשויים להזדקק לטפל במהירות בתיקון חם או להחליף משימות.

* **מטרה**: שומר באופן זמני שינויים שלא נשמרו (מוכנים ולא מוכנים) מספריית העבודה, ומאפשר מעבר בין הקשרים או עבודה על משהו אחר, ולאחר מכן החלה מחדש של השינויים.
* **פקודה**: \`git stash\`
    * דוגמה 1: \`git stash\` ישמור את כל השינויים שלך (מוכנים ולא מוכנים) וישאיר את ספריית העבודה נקייה.
    * \`git stash list\`: מציג מספר stashes.
    * \`git stash apply [stash@{n}]\`: מפעיל מחדש שינויים אך משאיר אותם ב-stash.
        * דוגמה: \`git stash apply stash@{0}\` יחיל את ה-stash האחרון.
    * \`git stash pop [stash@{n}]\`: מפעיל מחדש שינויים ומסיר אותם מה-stash.
        * דוגמה: \`git stash pop\` יחיל את ה-stash האחרון וימחק אותו.
    * \`git stash save "message"\`: נותן שם ל-stash.
        * דוגמה: \`git stash save "Work on login feature"\`
    * \`git stash -u\` או \`--include-untracked\`: שומר קבצים לא נתונים למעקב.
    * \`git stash -a\` או \`--all\`: שומר גם קבצים מתעלמים.
    * \`git stash drop [stash@{n}]\`: מסיר stash ספציפי.
* **מנגנון**: Stashes הם מקומיים למאגר ואינם מועברים ב-\`push\`.

\`git stash\` הוא מאיץ פרודוקטיביות המאפשר למפתחים לשמור על ספריית עבודה נקייה ולהתמקד במשימה אחת בכל פעם, מבלי לאבד עבודה בלתי גמורה.
        `,
      },
      {
        title: 'ביטול שינויים וכתיבה מחדש של היסטוריה: שחזור עבודה שאבדה: `git reflog`',
        content: `
בעוד ש-\`reset\` ו-\`revert\` מיועדים לתרחישי "ביטול" ספציפיים, \`git reflog\` פועל כ"היסטוריית ביטול" מקיפה כמעט לכל פעולת Git שמזיזה את \`HEAD\`. זוהי קו ההגנה האחרון מפני אובדן נתונים נתפס, אפילו עבור פעולות כמו \`git reset --hard\` שהן בלתי הפיכות בדרך כלל.

* **מטרה**: עוקב אחר שינויים שאינם חלק מהיסטוריית ה-commit הרגילה (לדוגמה, commits אבודים, ענפים שנמחקו, שינויים לאחר \`git reset --hard\`). הוא מתעד היכן \`HEAD\` והפניות ענפים היו לאחרונה.
* **פקודה**: \`git reflog\`
    * דוגמה: \`git reflog\` עשוי להציג:
        \`\`\`
        a1b2c3d HEAD@{0}: commit: Added new feature
        e4f5g6h HEAD@{1}: checkout: moving from old-branch to main
        i7j8k9l HEAD@{2}: commit (initial): Initial project setup
        \`\`\`
* **מנגנון**: רשומות Reflog מציינות את הערך הישן של הפניה (לדוגמה, \`HEAD@{3}\` פירושו "היכן \`HEAD\` היה לפני שני מהלכים").
* **שחזור**: ניתן להשתמש ב-\`git checkout HEAD@{n}\` או \`git reset --hard HEAD@{n}\` כדי לחזור למצב ספציפי. ניתן גם ליצור ענף חדש מרשומת reflog (\`git checkout -b <branch-name> HEAD@{n}\`).
    * דוגמה: אם בטעות מחקת ענף או ביצעת \`reset --hard\` ואיבדת עבודה, תוכל למצוא את ה-commit שאליו ברצונך לחזור ב-\`git reflog\` (לדוגמה, \`a1b2c3d\`) ואז להריץ: \`git reset --hard a1b2c3d\` כדי לשחזר את העבודה.
* **מגבלות**: עוקב רק אחר שינויי \`HEAD\`, לא שינויים שלא נשמרו. רשומות Reflog פגות תוקף (ברירת מחדל 90 יום לנגישים, 30 יום לבלתי נגישים).

\`git reflog\` הופך טעויות שעלולות להיות קטסטרופליות למצבים הניתנים לשחזור, ומגביר את ביטחון המפתחים ומאפשר ניסויים אגרסיביים יותר. זהו כלי קריטי לפתרון בעיות מתקדם ו"הצלת" עבודה שאבדה.
        `,
      },
      {
        title: 'פעולות מיוחדות: Cherry-Picking Commits: `git cherry-pick`',
        content: `
\`git cherry-pick\` מציע גישה "כירורגית" לשילוב שינויים, בניגוד להיקף הרחב יותר של \`merge\` או \`rebase\`. הוא מאפשר יישום סלקטיבי של commits ספציפיים, וזה חזק עבור תיקונים ממוקדים או שיתוף שינויים מבודדים.

* **מטרה**: בוחר commit Git שרירותי לפי הפניה מענף אחד ומחיל אותו על ה-\`HEAD\` הנוכחי של ענף אחר.
* **פקודה**: \`git cherry-pick <commitSha>\`
    * דוגמה: אם יש לך commit חשוב בענף \`feature/bugfix\` עם ID \`c0ffee1\` ואתה רוצה להעביר אותו לענף \`main\` מבלי למזג את כל הענף, נווט לענף \`main\` והקלד: \`git cherry-pick c0ffee1\`
* **מקרים שימוש**:
    * החזרת תיקוני באגים מענף פיתוח לענף יציב/שחרור.
    * החלת תיקונים חמים (hotfixes) על ענפי ייצור.
    * תיקון commits שהוצבו בטעות.
    * שימוש חוזר בשינויים על פני מספר ענפים.
* **מנגנון**: יוצר commit חדש עם אותם שינויים אך עם גיבוב שונה בענף היעד.
* **זהירות**: עלול לגרום ל-commits כפפולים. אינו תחליף ל-\`git merge\` או \`git rebase\` לשילוב תכונות שלמות.

פקודה זו בעלת ערך לשמירה על ענפי שחרור נקיים ולהחלת תיקונים קריטיים מבלי להכניס עבודת פיתוח לא קשורה, מה שקריטי.
        `,
      },
    ],
  },
];

// Accordion component to display collapsible sections
const Accordion = ({ title, content }) => {
  const [isOpen, setIsOpen] = useState(false);

  // Function to render Markdown content including tables
  const renderMarkdown = (markdown) => {
    // Basic Markdown to HTML conversion for headings, lists, bold, italics
    let html = markdown
      .replace(/^### (.*)$/gm, '<h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">$1</h3>') // H3
      .replace(/^## (.*)$/gm, '<h2 class="text-2xl font-bold text-gray-900 mt-8 mb-4">$1</h2>')   // H2
      .replace(/^# (.*)$/gm, '<h1 class="text-3xl font-bold text-gray-900 mt-10 mb-5">$1</h1>')    // H1
      .replace(/^\* (.*)$/gm, '<li class="mb-2 pr-4 relative before:content-[\'•\'] before:absolute before:right-0 before:text-blue-500"><span>$1</span></li>')  // Unordered list items with custom bullet
      .replace(/(\*\*|__)(.*?)\1/g, '<strong>$2</strong>') // Bold
      .replace(/(\*|_)(.*?)\1/g, '<em>$2</em>')    // Italic
      .replace(/`(.*?)`/g, '<code class="bg-blue-100 text-blue-800 p-1 rounded-md text-sm font-mono whitespace-nowrap">$1</code>'); // Inline code

    // Convert list items to ul
    html = html.replace(/(<li.*?<\/li>(\s*<li.*?<\/li>)*)/gs, (match) => `<ul class="list-none pr-4">${match}</ul>`);

    // Handle tables - this is a simplified approach and might need a more robust markdown parser for complex tables
    const tableRegex = /\|(.+)\|(?:\r?\n|\r)\s*\|(?:\s*[-:]+\s*\|)+\s*(?:\r?\n|\r)(?:\|(.+)\|(?:\r?\n|\r)?)*/g;
    html = html.replace(tableRegex, (match) => {
      const lines = match.split(/\r?\n|\r/).filter(line => line.trim() !== '');
      if (lines.length < 2) return match; // Not a valid table

      const headerLine = lines[0];
      const separatorLine = lines[1];

      if (!headerLine.startsWith('|') || !separatorLine.startsWith('|') || !separatorLine.match(/\|(?:\s*[-:]+\s*\|)+/)) {
        return match; // Not a table, or separator is missing
      }

      const headers = headerLine.split('|').slice(1, -1).map(h => h.trim());
      const bodyLines = lines.slice(2);

      let tableHtml = '<div class="overflow-x-auto"><table class="min-w-full bg-white border border-gray-300 rounded-lg shadow-md my-4 text-sm">';
      tableHtml += '<thead><tr class="bg-blue-50 text-blue-800">';
      headers.forEach(header => {
        tableHtml += `<th class="py-3 px-4 border-b border-gray-300 font-semibold text-right">${header}</th>`;
      });
      tableHtml += '</tr></thead>';

      tableHtml += '<tbody>';
      bodyLines.forEach(line => {
        const cells = line.split('|').slice(1, -1).map(c => c.trim());
        tableHtml += '<tr class="hover:bg-gray-50">';
        cells.forEach(cell => {
          tableHtml += `<td class="py-2 px-4 border-b border-gray-200 text-right">${cell}</td>`;
        });
        tableHtml += '</tr>';
      });
      tableHtml += '</tbody></table></div>';
      return tableHtml;
    });

    // Replace multiple newlines with paragraph tags
    html = html.split('\n\n').map(paragraph => {
        // Don't wrap if it's already a block element like <ul>, <table>, <h3>, etc.
        if (paragraph.trim().startsWith('<ul') || paragraph.trim().startsWith('<table') || paragraph.trim().startsWith('<h') || paragraph.trim().startsWith('<div class="overflow-x-auto"')) {
            return paragraph;
        }
        return `<p>${paragraph.trim()}</p>`;
    }).join('');

    // Remove empty <p></p> tags that might be created
    html = html.replace(/<p>\s*<\/p>/g, '');

    return { __html: html };
  };

  return (
    <div className="border border-gray-200 rounded-lg mb-4 shadow-sm overflow-hidden">
      <button
        className="flex justify-between items-center w-full p-4 text-right font-semibold text-gray-800 bg-gray-50 hover:bg-gray-100 rounded-t-lg focus:outline-none transition-all duration-200 ease-in-out"
        onClick={() => setIsOpen(!isOpen)}
      >
        <span className="text-lg">{title}</span>
        <svg
          className={`w-6 h-6 text-gray-600 transition-transform duration-300 ${isOpen ? 'rotate-180' : ''}`}
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path>
        </svg>
      </button>
      {isOpen && (
        <div className="p-6 bg-white rounded-b-lg text-gray-700 leading-relaxed text-right"
             dangerouslySetInnerHTML={renderMarkdown(content)}
        ></div>
      )}
    </div>
  );
};

// Main App component
const App = () => {
  const [activeTab, setActiveTab] = useState(guideContent[0].id); // Default to the first tab
  const [showOverlayMessage, setShowOverlayMessage] = useState(false);
  const [overlayText, setOverlayText] = useState('');

  const soloGuideContentFull = {
    title: 'VI. מדריך זרימת עבודה למפתח יחיד',
    icon: <Workflow className="w-5 h-5" />,
    sections: [
      {
        title: 'דרישות מקדימות',
        content: `
לפני שמתחילים, ודא שהדרישות הבאות מתקיימות:
* **Git מותקן במערכת שלך**: Git הוא הכלי הבסיסי לבקרת גרסאות. אם אינו מותקן, תוכל למצוא הוראות התקנה באתר הרשמי של Git.
* **חשבון GitHub**: GitHub היא פלטפורמת אירוח למאגרי Git המאפשרת שיתוף קוד, מעקב אחר שינויים ושיתוף פעולה. אם אין לך חשבון, תוכל להירשם בחינם באתר GitHub.
* **אסימון גישה אישי (Personal Access Token - PAT)**: מומלץ להשתמש ב-PAT במקום סיסמת ה-GitHub שלך לצורך אימות מאובטח יותר בטרמינל.
        `,
      },
      {
        title: 'יצירת אסימון גישה אישי (PAT) (פעם ראשונה בלבד)',
        content: `
אסימון גישה אישי הוא דרך מאובטחת לאמת את עצמך ב-GitHub מהטרמינל, במקום להשתמש בסיסמה שלך.
1.  **התחבר ל-GitHub**: היכנס לחשבון ה-GitHub שלך דרך הדפפת.
2.  **נווט להגדרות אסימוני גישה**: עבור לכתובת: \`https://github.com/settings/tokens\` (או נווט דרך הגדרות הפרופיל שלך -> Developer settings -> Personal access tokens).
3.  **צור אסימון חדש**: לחץ על "Generate new token" (או "Generate new token (classic)" עבור אסימונים קלאסיים).
4.  **הגדר היקף הרשאות**: בחר את ההרשאות (scopes) הנדרשות. לרוב הפעולות, סמן לפחות את "repo" כדי לאפשר גישה למאגרים.
5.  **בחר תאריך תפוגה**: הגדר תאריך תפוגה לאסימון. מומלץ לבחור תאריך תפוגה קצר יחסית (לדוגמה, 7 ימים או 30 ימים) כדי למזער סיכונים אבטחתיים.
6.  **צור אסימון**: לחץ על "Generate token".
7.  **העתק את האסימון**: **חשוב מאוד!** העתק את האסימון שנוצר מיד. לא תוכל לראות אותו שוב לאחר שתעזוב את הדף. שמור אותו במקום מאובטח (כמו מנהל סיסמאות).
        `,
      },
      {
        title: 'שיבוט המאגר (Clone the Repository)',
        content: `
שיבוט מאגר יוצר עותק מקומי של המאגר המרוחק במחשב שלך, כולל כל היסטוריית הקבצים והענפים.
* **פקודה**: \`git clone https://github.com/<your-username>/<your-repo>.git\`
    * **הסבר**: החלף את \`<your-username>\` בשם המשתמש שלך ב-GitHub ואת \`<your-repo>\` בשם המאגר שברצונך לשבט.
    * **דוגמה**: \`git clone https://github.com/myusername/my-project.git\`
* **מעבר לספריית המאגר**: לאחר השיבוט, נווט לספרייה החדשה שנוצרה: \`cd <your-repo>\`
    * **דוגמה**: \`cd my-project\`
        `,
      },
      {
        title: 'הוספה או עריכה של קבצים/סקריפטים',
        content: `
לאחר שיבוט המאגר, תוכל להתחיל לעבוד על הקבצים.
* **העברת קובץ קיים**: אם יש לך קובץ שברצונך להוסיף למאגר, תוכל להעביר אותו לספרייה המתאימה בתוך המאגר.
    * **פקודה**: \`mv my_script.sh scripts/\`
    * **הסבר**: פקודה זו מעבירה את הקובץ \`my_script.sh\` (שנמצא בתיקייה הנוכחית) לתיקייה \`scripts/\` בתוך המאגר.
* **יצירה או עריכה של קובץ חדש**:
    * **פקודה**: \`nano scripts/my_script.sh\`
    * **הסבר**: פקודה זו פותחת את עורך הטקסט \`nano\` (עורך טקסט פשוט מבוסס טרמינל) כדי ליצור או לערוך את הקובץ \`my_script.sh\` בתוך תיקיית \`scripts/\`. תוכל להשתמש בכל עורך טקסט אחר שנוח לך (לדוגמה, VS Code, Sublime Text).
        `,
      },
      {
        title: 'הפיכת הסקריפט לניתן להרצה (Executable)',
        content: `
אם הקובץ שהוספת הוא סקריפט (לדוגמה, קובץ Shell), ייתכן שתרצה להפוך אותו לניתן להרצה.
* **פקודה**: \`chmod +x scripts/my_script.sh\`
* **הסבר**: פקודה זו מעניקה הרשאות הרצה (execute) לקובץ \`my_script.sh\`. \`chmod\` משמשת לשינוי הרשאות קבצים, ו-\`+x\` מוסיף הרשאת הרצה.
        `,
      },
      {
        title: 'שמירה וביצוע שינויים (Save & Commit Your Changes)',
        content: `
לאחר שביצעת שינויים בקבצים, עליך לשמור אותם במאגר ה-Git המקומי. זהו תהליך דו-שלבי: הכנה (staging) ולאחר מכן שמירה (committing).
* **הכנת קבצים**:
    * **פקודה**: \`git add scripts/my_script.sh\`
    * **הסבר**: פקודה זו מוסיפה את הקובץ \`my_script.sh\` לאזור ההכנה (staging area). אזור ההכנה הוא אזור ביניים שבו אתה בוחר אילו שינויים לכלול ב-commit הבא.
    * **טיפ**: כדי להוסיף את כל השינויים הנוכחיים בספרייה (קבצים חדשים, קבצים ששונו, קבצים שנמחפו), השתמש ב-\`git add .\`
* **ביצוע שינוי (Commit)**:
    * **פקודה**: \`git commit -m "הודעת קומיט משמעותית"\`
    * **הסבר**: פקודה זו שומרת את השינויים שהוכנו במאגר ה-Git המקומי. הודעת ה-commit (\`-m "..."\`) מתארת את השינויים שבוצעו. חשוב לכתוב הודעות ברורות ותמציתיות.
    * **דוגמה**: \`git commit -m "Add new script for user management"\`
        `,
      },
      {
        title: 'דחיפה ל-GitHub (Push to GitHub)',
        content: `
לאחר ששמרת את השינויים במאגר המקומי, עליך לדחוף אותם למאגר המרוחק ב-GitHub כדי לשתף אותם.
* **פקודה**: \`git push\`
* **הסבר**: פקודה זו מעלה את השינויים מהמאגר המקומי שלך למאגר המרוחק ב-GitHub.
* **כאשר תתבקש**:
    * **שם משתמש**: הזן את שם המשתמש שלך ב-GitHub.
    * **סיסמה**: הדבק את אסימון הגישה האישי (PAT) שיצרת בשלב 2.
        `,
      },
      {
        title: 'שמירת אסימון הגישה לשימוש עתידי (אופציונלי)',
        content: `
כדי להימנע מהזנה חוזרת של אסימון הגישה בכל פעם שאתה מבצע \`git push\` או \`git pull\`, תוכל לשמור אותו.
* **פקודה**: \`git config --global credential.helper store\`
* **הסבר**: פקודה זו מורה ל-Git לשמור את פרטי האימות שלך (שם משתמש ו-PAT) בקובץ תצורה, כך שלא תצטרך להזין אותם מחדש בפעולות עתידיות.
* **אזהרה**: פעולה זו שומרת את ה-PAT בטקסט פשוט במחשב שלך. ודא שהמחשב שלך מאובטח.
        `,
      },
      {
        title: 'משיכת שינויים לפני עבודה (Pull before you work)',
        content: `
לפני שאתה מתחיל לעבוד על פרויקט, תמיד מומלץ למשוך את השינויים האחרונים מהמאגר המרוחק כדי לוודא שאתה עובד על הגרסה העדכנית ביותר. זה עוזר למנוע קונפליקטים במיזוג בהמשך.
* **פקודה**: \`git pull origin main\`
* **הסבר**: פקודה זו מושכת את כל השינויים מענף ה-\`main\` במאגר המרוחק (\`origin\`) וממזגת אותם לענף המקומי שלך.
        `,
      },
    ],
  };

  const collabGuideContentFull = {
    title: 'VII. מדריך זרימת עבודה לשיתוף פעולה',
    icon: <Workflow className="w-5 h-5" />,
    sections: [
      {
        title: 'דרישות מקדימות',
        content: `
לפני שמתחילים בשיתוף פעולה, ודא שהדרישות הבאות מתקיימות:
* **לכל משתף פעולה חייב להיות חשבון GitHub**: כל חבר צוות צריך חשבון GitHub כדי לתרום למאגר.
* **בעל המאגר חייב להוסיף משתפי פעולה**: בעל המאגר המקורי ב-GitHub צריך להוסיף את חברי הצוות כמשתפי פעולה. ניתן לעשות זאת תחת הגדרות המאגר: \`https://github.com/<owner>/<repo>/settings/access\`
* **Git מותקן**: ודא ש-Git מותקן על כל מכונה של משתף פעולה.
* **כל משתמש חייב ליצור אסימון גישה אישי (PAT) משלו**: מטעמי אבטחה, כל משתף פעולה צריך ליצור PAT ייחודי משלו לשימוש עם הטרמינל. (ראה מדריך למפתח יחיד, שלב 2, להוראות).
        `,
      },
      {
        title: 'שיבוט המאגר (Clone the Repository)',
        content: `
כמשתף פעולה, השלב הראשון הוא לשבט את המאגר המשותף למחשב המקומי שלך.
* **פקודה**: \`git clone https://github.com/<owner>/<repo>.git\`
    * **הסבר**: החלף את \`<owner>\` בשם המשתמש של בעל המאגר ואת \`<repo>\` בשם המאגר המשותף.
    * **דוגמה**: \`git clone https://github.com/teamleader/shared-project.git\`
* **מעבר לספריית המאגר**: נווט לספרייה החדשה שנוצרה: \`cd <repo>\`
    * **דוגמה**: \`cd shared-project\`
        `,
      },
      {
        title: 'העברה או יצירה של סקריפט',
        content: `
לאחר שיבוט המאגר, תוכל להוסיף או לערוך קבצים.
* **העברת קובץ קיים**: אם יש לך סקריפט שברצונך להוסיף, העבר אותו לתיקיית \`scripts/\` בתוך המאגר.
    * **פקודה**: \`mv ~/Downloads/my_script.sh scripts/\`
    * **הסבר**: מעביר את הקובץ \`my_script.sh\` מתיקיית ההורדות שלך לתיקיית \`scripts/\` במאגר.
* **יצירה או עריכה של קובץ חדש**:
    * **פקודה**: \`nano scripts/my_script.sh\`
    * **הסבר**: פותח את עורך הטקסט \`nano\` ליצירה או עריכה של הקובץ.
        `,
      },
      {
        title: 'הפיכת הסקריפט לניתן להרצה',
        content: `
אם הקובץ שהוספת הוא סקריפט, ודא שהוא ניתן להרצה.
* **פקודה**: \`chmod +x scripts/my_script.sh\`
* **הסבר**: מעניק הרשאות הרצה לקובץ.
        `,
      },
      {
        title: 'הכנה ושמירה (Stage and Commit)',
        content: `
שמור את השינויים שביצעת במאגר המקומי.
* **הכנת קבצים**:
    * **פקודה**: \`git add scripts/my_script.sh\`
    * **הסבר**: מוסיף את הקובץ לאזור ההכנה.
    * **טיפ**: כדי להוסיף מספר קבצים בבת אחת, לדוגמה כל קבצי ה-shell בתיקיית \`scripts/\`: \`git add scripts/*.sh\`
* **ביצוע שינוי (Commit)**:
    * **פקודה**: \`git commit -m "הוספת סקריפט חדש עבור XYZ"\`
    * **הסבר**: שומר את השינויים שהוכנו עם הודעה ברורה.
        `,
      },
      {
        title: 'דחיפה ל-GitHub (Push to GitHub)',
        content: `
דחוף את השינויים שלך למאגר המרוחק ב-GitHub.
* **פקודה**: \`git push\`
* **כאשר תתבקש**:
    * **שם משתמש**: הזן את שם המשתמש שלך ב-GitHub.
    * **סיסמה**: הדבק את אסימון הגישה האישי (PAT) שלך.
        `,
      },
      {
        title: 'שמירת אסימון הגישה כדי למנוע הזנה חוזרת',
        content: `
מומלץ לשמור את אסימון הגישה שלך כדי לייעל את זרימת העבודה.
* **פקודה**: \`git config --global credential.helper store\`
* **אזהרה**: פעולה זו שומרת את ה-PAT בטקסט פשוט במחשב שלך. ודא שהמחשב שלך מאובטח.
        `,
      },
      {
        title: 'תמיד משוך לפני דחיפה (Always pull before push)',
        content: `
כדי למנוע קונפליקטים במיזוג ולעבוד על הגרסה העדכנית ביותר, תמיד משוך שינויים מהמאגר המרוחק לפני שאתה דוחף את השינויים שלך.
* **פקודה**: \`git pull origin main\`
* **הסבר**: פקודה זו מושכת שינויים מענף ה-\`main\` המרוחק וממזגת אותם לענף המקומי שלך.
* **פתרון קונפליקטים**: אם ישנם קונפליקטים במיזוג, Git יודיע לך. תצטרך לפתור אותם ידנית בקבצים המושפעים, להוסיף את הקבצים המתוקנים ל-staging (\`git add\`) ולבצע commit נוסף כדי להשלים את המיזוג.
        `,
      },
    ],
  };

  const updatedGuideContent = [
    ...guideContent,
    soloGuideContentFull,
    collabGuideContentFull,
  ];

  const handleDoNotClick = () => {
    setOverlayText('נפרץ לך המחשב!');
    setShowOverlayMessage(true);

    setTimeout(() => {
      setOverlayText('סתםםםםםםם');
    }, 3000); // Change text after 3 seconds

    setTimeout(() => {
      setShowOverlayMessage(false);
      setOverlayText(''); // Clear text
    }, 6000); // Hide overlay after another 3 seconds (total 6 seconds)
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4 sm:p-6 lg:p-8 font-inter antialiased">
      <style>
        {`
          @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
          body { font-family: 'Inter', sans-serif; direction: rtl; text-align: right; }
          /* General RTL adjustments for lists */
          ul {
            list-style-type: none; /* Remove default bullet */
            padding-right: 0; /* Remove default padding */
            margin-right: 1.5rem; /* Indent from the right */
          }
          ul li {
            position: relative;
            padding-right: 1.5rem; /* Space for custom bullet */
          }
          ul li::before {
            content: '•'; /* Custom bullet point */
            position: absolute;
            right: 0;
            color: #3b82f6; /* Blue-500 */
            font-weight: bold;
          }
          ol {
            list-style-type: decimal;
            padding-right: 1.5rem; /* Adjust for Hebrew RTL */
            margin-right: 1.5rem;
          }
          li {
            margin-bottom: 0.5rem;
          }
          /* Custom styling for headings within markdown content */
          .p-6 h1, .p-6 h2, .p-6 h3, .p-6 h4, .p-6 h5, .p-6 h6 {
            font-weight: 700;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            text-align: right;
          }
          .p-6 h1 { font-size: 2.25rem; }
          .p-6 h2 { font-size: 1.875rem; }
          .p-6 h3 { font-size: 1.5rem; }
          .p-6 p {
            margin-bottom: 1rem;
          }
          /* Table specific styling */
          table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
          }
          th, td {
            border: 1px solid #e2e8f0; /* Tailwind gray-200 */
            padding: 0.85rem;
            text-align: right; /* Align text to the right for Hebrew */
          }
          th {
            background-color: #eff6ff; /* Tailwind blue-50 */
            font-weight: 600;
            color: #1e40af; /* Tailwind blue-800 */
          }
          tbody tr:nth-child(even) {
            background-color: #f9fafb; /* Light alternating row color */
          }
          tbody tr:hover {
            background-color: #f3f4f6; /* Hover effect for rows */
          }
          /* Code block styling */
          pre {
            background-color: #2d3748; /* Darker blue-gray for code blocks */
            color: #f9fafb; /* Light text */
            padding: 1.25rem;
            border-radius: 0.75rem;
            overflow-x: auto;
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace; /* Monospace font for code */
            margin-top: 1rem;
            margin-bottom: 1rem;
            direction: ltr; /* Ensure code is LTR */
            text-align: left; /* Ensure code is left-aligned */
          }
          code {
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
          }
          .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease-in-out;
            opacity: 0;
            pointer-events: none; /* Allow clicks through when hidden */
          }
          .overlay.visible {
            opacity: 1;
            pointer-events: auto; /* Enable clicks when visible */
          }
          .overlay-content {
            background-color: #fff;
            padding: 3rem;
            border-radius: 1rem;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease-out;
          }
          .overlay.visible .overlay-content {
            transform: scale(1);
          }
          .overlay-text {
            font-size: 3rem; /* Larger text */
            font-weight: bold;
            color: #dc2626; /* Red-600 */
            animation: pulse 1.5s infinite;
            margin-bottom: 1rem;
          }
          .overlay-subtext {
            font-size: 2rem; /* Larger subtext */
            font-weight: 600;
            color: #4b5563; /* Gray-700 */
          }
          @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
          }
        `}
      </style>

      {/* Overlay Message */}
      <div className={`overlay ${showOverlayMessage ? 'visible' : ''}`}>
        <div className="overlay-content">
          <div className="overlay-text">{overlayText}</div>
        </div>
      </div>

      <div className="max-w-5xl mx-auto bg-white rounded-2xl shadow-2xl overflow-hidden border border-gray-100 relative">
        <header className="p-10 bg-gradient-to-r from-blue-700 to-indigo-800 text-white text-center rounded-t-2xl">
          <h1 className="text-4xl sm:text-5xl font-extrabold mb-3 leading-tight">מדריך מקיף ל-Git ולטרמינל</h1>
          <p className="text-blue-200 text-xl sm:text-2xl font-light">ללמוד את יסודות ה-CLI, Git ו-GitHub מהבסיס ועד לרמה מתקדמת</p>
        </header>

        {/* "Do Not Click" Button */}
        <button
          className="absolute top-4 left-4 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 z-50"
          onClick={handleDoNotClick}
        >
          לא ללחוץ
        </button>

        {/* Tabs for main sections */}
        <div className="flex flex-wrap justify-center bg-blue-800 text-white p-3 border-b-4 border-blue-900">
          {updatedGuideContent.map((tab) => (
            <button
              key={tab.id}
              className={`flex items-center px-5 py-3 mx-1 my-1 rounded-full text-base font-medium transition-all duration-300 ease-in-out
                ${activeTab === tab.id
                  ? 'bg-blue-600 text-white shadow-md transform scale-105'
                  : 'bg-blue-700 hover:bg-blue-600 text-blue-200 hover:text-white'
                }`}
              onClick={() => setActiveTab(tab.id)}
            >
              {tab.icon && <span className="ml-2">{tab.icon}</span>}
              {tab.title.split('. ')[1] || tab.title}
            </button>
          ))}
        </div>

        {/* Content Area */}
        <div className="p-8 bg-gray-50">
          {updatedGuideContent.map((tab) => (
            activeTab === tab.id && (
              <div key={tab.id} className="fade-in">
                <h2 className="text-3xl font-bold text-gray-900 mb-6 border-b-2 border-blue-200 pb-3 text-right">{tab.title}</h2>
                {tab.sections.map((section, index) => (
                  <Accordion key={index} title={section.title} content={section.content} />
                ))}
              </div>
            )
          ))}
        </div>

        <footer className="p-8 bg-blue-900 text-blue-200 text-center rounded-b-2xl">
          <p className="text-base mb-2">
            מדריך זה נוצר כדי לספק הבנה מעמיקה של Git, GitHub והטרמינל.
            זכור תמיד את חשיבות האבטחה, ובפרט, **לעולם אל תשתף אסימוני גישה (Tokens)**.
          </p>
          <p className="text-sm">
            © 2024 כל הזכויות שמורות.
          </p>
        </footer>
      </div>
    </div>
  );
};

export default App;

